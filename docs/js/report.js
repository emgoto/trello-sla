/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/report.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/report.ts":
/*!***********************!*\
  !*** ./src/report.ts ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _trello_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trello-util */ \"./src/trello-util.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst t = TrelloPowerUp.iframe();\nconst humanReadableTimeStamp = (milliseconds) => moment(milliseconds).format(\"YYYY-MM-DD k:mm:ss\");\nconst generateReport = () => __awaiter(void 0, void 0, void 0, function* () {\n    // TODO: only returns 1000 actions, so won't work on boards with large histories\n    const actions = yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getBoardActions\"])(t);\n    const config = yield t.arg('currentConfig');\n    const actionsPerCard = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"getActionsPerCard\"])(actions);\n    const cardIds = Object.keys(actionsPerCard);\n    let csv = \"Name,Start time, End time, Time remaining\\n\";\n    cardIds.map(cardId => {\n        const cardActions = actionsPerCard[cardId];\n        const startTime = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"getStartTime\"])(cardActions, config.startCondition);\n        let endTime;\n        if (startTime) {\n            csv += cardActions[0].data.card.name;\n            endTime = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"getEndTime\"])(cardActions, config.endCondition, startTime);\n            csv += \",\" + humanReadableTimeStamp(startTime) + \",\";\n            if (endTime) {\n                csv += humanReadableTimeStamp(endTime);\n            }\n            csv += \",\";\n            const minutesRemaining = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"getMinutesRemaining\"])(startTime, endTime, config);\n            csv += Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"getHumanReadableTime\"])(minutesRemaining);\n            csv += '\\n';\n        }\n    });\n    return csv;\n});\nt.render(() => __awaiter(void 0, void 0, void 0, function* () {\n    const report = yield generateReport();\n    document.querySelector('#downloadLink').classList.remove('hidden');\n    document.querySelector('.loadingSpinner').classList.add('hidden');\n    const button = document.querySelector('#downloadLink');\n    button.href = 'data:text/csv;charset=utf-8,' + encodeURI(report);\n    button.target = '_blank';\n    button.download = 'sla.csv';\n}));\n// console.log(csv);\n// var hiddenElement = document.createElement('a');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVwb3J0LnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9yZXBvcnQudHM/ODI2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRCb2FyZEFjdGlvbnMgfSBmcm9tICcuL3RyZWxsby11dGlsJztcbmltcG9ydCB7IGdldEFjdGlvbnNQZXJDYXJkLCBnZXRTdGFydFRpbWUsIGdldEVuZFRpbWUsIGdldE1pbnV0ZXNSZW1haW5pbmcsIGdldEh1bWFuUmVhZGFibGVUaW1lIH0gZnJvbSAnLi91dGlsJztcblxuZGVjbGFyZSBjb25zdCBtb21lbnQ6IGFueTtcbmRlY2xhcmUgY29uc3QgVHJlbGxvUG93ZXJVcDogYW55O1xuY29uc3QgdCA9IFRyZWxsb1Bvd2VyVXAuaWZyYW1lKCk7XG5cbmNvbnN0IGh1bWFuUmVhZGFibGVUaW1lU3RhbXAgPSAobWlsbGlzZWNvbmRzOiBudW1iZXIpOiBzdHJpbmcgPT5cbiAgICBtb21lbnQobWlsbGlzZWNvbmRzKS5mb3JtYXQoXCJZWVlZLU1NLUREIGs6bW06c3NcIik7XG5cbmNvbnN0IGdlbmVyYXRlUmVwb3J0ID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIFRPRE86IG9ubHkgcmV0dXJucyAxMDAwIGFjdGlvbnMsIHNvIHdvbid0IHdvcmsgb24gYm9hcmRzIHdpdGggbGFyZ2UgaGlzdG9yaWVzXG4gICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0IGdldEJvYXJkQWN0aW9ucyh0KTtcbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCB0LmFyZygnY3VycmVudENvbmZpZycpO1xuXG4gICAgY29uc3QgYWN0aW9uc1BlckNhcmQgPSBnZXRBY3Rpb25zUGVyQ2FyZChhY3Rpb25zKTtcbiAgICBjb25zdCBjYXJkSWRzID0gT2JqZWN0LmtleXMoYWN0aW9uc1BlckNhcmQpO1xuXG4gICAgbGV0IGNzdiA9IFwiTmFtZSxTdGFydCB0aW1lLCBFbmQgdGltZSwgVGltZSByZW1haW5pbmdcXG5cIjtcblxuICAgIGNhcmRJZHMubWFwKGNhcmRJZCA9PiB7XG4gICAgICAgIGNvbnN0IGNhcmRBY3Rpb25zID0gYWN0aW9uc1BlckNhcmRbY2FyZElkXTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gZ2V0U3RhcnRUaW1lKGNhcmRBY3Rpb25zLCBjb25maWcuc3RhcnRDb25kaXRpb24pO1xuICAgICAgICBsZXQgZW5kVGltZTtcbiAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgY3N2ICs9IGNhcmRBY3Rpb25zWzBdLmRhdGEuY2FyZC5uYW1lO1xuICAgICAgICAgICAgZW5kVGltZSA9IGdldEVuZFRpbWUoY2FyZEFjdGlvbnMsIGNvbmZpZy5lbmRDb25kaXRpb24sIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBjc3YgKz0gXCIsXCIgKyBodW1hblJlYWRhYmxlVGltZVN0YW1wKHN0YXJ0VGltZSkgKyBcIixcIjtcbiAgICAgICAgICAgIGlmIChlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgY3N2ICs9IGh1bWFuUmVhZGFibGVUaW1lU3RhbXAoZW5kVGltZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNzdiArPSBcIixcIjtcblxuICAgICAgICAgICAgY29uc3QgbWludXRlc1JlbWFpbmluZyA9IGdldE1pbnV0ZXNSZW1haW5pbmcoc3RhcnRUaW1lLCBlbmRUaW1lLCBjb25maWcpO1xuICAgICAgICAgICAgY3N2ICs9IGdldEh1bWFuUmVhZGFibGVUaW1lKG1pbnV0ZXNSZW1haW5pbmcpO1xuICAgICAgICAgICAgY3N2ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGNzdjtcbn07XG5cbnQucmVuZGVyKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBnZW5lcmF0ZVJlcG9ydCgpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkb3dubG9hZExpbmsnKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9hZGluZ1NwaW5uZXInKS5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICBjb25zdCBidXR0b246IEhUTUxBbmNob3JFbGVtZW50PSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZG93bmxvYWRMaW5rJyk7XG4gICAgYnV0dG9uLmhyZWYgPSAnZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LCcgKyBlbmNvZGVVUkkocmVwb3J0KTtcbiAgICBidXR0b24udGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgYnV0dG9uLmRvd25sb2FkID0gJ3NsYS5jc3YnO1xufSk7XG5cblxuLy8gY29uc29sZS5sb2coY3N2KTtcbi8vIHZhciBoaWRkZW5FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBSUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/report.ts\n");

/***/ }),

/***/ "./src/trello-util.ts":
/*!****************************!*\
  !*** ./src/trello-util.ts ***!
  \****************************/
/*! exports provided: Condition, CardActionType, getConfigurations, setConfigurations, getSlaData, setSlaData, getToken, setToken, getBoardActions, getCardActions, getLists */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Condition\", function() { return Condition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CardActionType\", function() { return CardActionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getConfigurations\", function() { return getConfigurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setConfigurations\", function() { return setConfigurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSlaData\", function() { return getSlaData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setSlaData\", function() { return setSlaData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getToken\", function() { return getToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setToken\", function() { return setToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBoardActions\", function() { return getBoardActions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCardActions\", function() { return getCardActions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLists\", function() { return getLists; });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst key = '652d72f229f65b3457533bd55fdcf436';\n// Right now we only provide being in a column as starting the SLA\nvar Condition;\n(function (Condition) {\n    Condition[\"ColumnName\"] = \"COLUMN_NAME\";\n})(Condition || (Condition = {}));\nvar CardActionType;\n(function (CardActionType) {\n    CardActionType[\"createCard\"] = \"createCard\";\n    CardActionType[\"emailCard\"] = \"emailCard\";\n    CardActionType[\"copyCard\"] = \"copyCard\";\n    CardActionType[\"updateCard\"] = \"updateCard\";\n})(CardActionType || (CardActionType = {}));\nconst getConfigurations = (t) => t.get('board', 'shared', 'config');\nconst setConfigurations = (t, config) => t.set('board', 'shared', 'config', config);\nconst getSlaData = (t) => t.get('card', 'shared', 'slaData');\nconst setSlaData = (t, slaData) => t.set('card', 'shared', 'slaData', slaData);\nconst getToken = (t) => t.get('member', 'private', 'authToken');\nconst setToken = (t, token) => t.set('member', 'private', 'authToken', token);\n/**\n * TODO: the problem with getting all board actions is that there is a limit of 1000\n * And that the actions for closed cards are also counted.\n */\nconst getBoardActions = (t) => __awaiter(void 0, void 0, void 0, function* () {\n    const { board: boardId } = t.getContext();\n    const token = yield getToken(t);\n    const url = `https://api.trello.com/1/boards/${boardId}/actions?limit=1000&filter=updateCard:idList,createCard&member=false&memberCreator=false&key=${key}&token=${token}`;\n    return axios.get(url)\n        .then(response => {\n        return response.data;\n    })\n        .catch((e) => {\n        if (e && e.response && e.response.status && e.response.status === 401) {\n            setToken(t, undefined);\n        }\n    });\n});\nconst getCardActions = (t) => __awaiter(void 0, void 0, void 0, function* () {\n    const { card: cardId } = t.getContext();\n    const token = yield getToken(t);\n    const url = `https://api.trello.com/1/cards/${cardId}/actions?filter=updateCard:idList,createCard&key=${key}&token=${token}`;\n    return axios.get(url).then(response => response.data).catch((e) => {\n        if (e && e.response && e.response.status && e.response.status === 401) {\n            setToken(t, undefined);\n        }\n    });\n});\nconst getLists = (t) => __awaiter(void 0, void 0, void 0, function* () {\n    const { board: boardId } = t.getContext();\n    const token = yield getToken(t);\n    const url = `https://api.trello.com/1/boards/${boardId}/lists?cards=none&filter=open&key=${key}&token=${token}`;\n    return axios.get(url).then(response => response.data).catch((e) => {\n        if (e && e.response && e.response.status && e.response.status === 401) {\n            setToken(t, undefined);\n        }\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHJlbGxvLXV0aWwudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RyZWxsby11dGlsLnRzP2JhYjciXSwic291cmNlc0NvbnRlbnQiOlsiZGVjbGFyZSBjb25zdCBheGlvczogYW55O1xuXG5jb25zdCBrZXkgPSAnNjUyZDcyZjIyOWY2NWIzNDU3NTMzYmQ1NWZkY2Y0MzYnO1xuXG4vLyBSaWdodCBub3cgd2Ugb25seSBwcm92aWRlIGJlaW5nIGluIGEgY29sdW1uIGFzIHN0YXJ0aW5nIHRoZSBTTEFcbmV4cG9ydCBlbnVtIENvbmRpdGlvbiB7XG4gICAgQ29sdW1uTmFtZSA9IFwiQ09MVU1OX05BTUVcIixcbn1cblxuZXhwb3J0IGVudW0gQ2FyZEFjdGlvblR5cGUgeyBcbiAgICBjcmVhdGVDYXJkID0gXCJjcmVhdGVDYXJkXCIsXG4gICAgZW1haWxDYXJkID0gXCJlbWFpbENhcmRcIixcbiAgICBjb3B5Q2FyZCA9IFwiY29weUNhcmRcIixcbiAgICB1cGRhdGVDYXJkID0gXCJ1cGRhdGVDYXJkXCJcbn1cblxuZXhwb3J0IHR5cGUgU2xhQ29uZGl0aW9uID0ge1xuICAgIHR5cGU6IENvbmRpdGlvbjtcbiAgICBpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBTbGFDb25maWd1cmF0aW9uID0ge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHN0YXJ0Q29uZGl0aW9uOiBTbGFDb25kaXRpb247XG4gICAgZW5kQ29uZGl0aW9uOiBTbGFDb25kaXRpb247XG4gICAgdGltZTogbnVtYmVyOyAvLyBNaW51dGVzXG59XG5cbmV4cG9ydCB0eXBlIFNsYURhdGEgPSB7XG4gICAgc3RhcnRUaW1lPzogbnVtYmVyOyAvLyBVbml4IHRpbWVzdGFtcCBtaWxsaXNlY29uZHMuIE9ubHkgZXhpc3RzIGlmIFNMQSBoYXMgc3RhcnRlZFxuICAgIGVuZFRpbWU/OiBudW1iZXI7IC8vIFVuaXggdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcy4gT25seSBleGlzdHMgaWYgU0xBIGhhcyBlbmRlZFxufVxuXG5leHBvcnQgdHlwZSBTbGFEYXRhTWFwID0ge1xuICAgIFtpZDogbnVtYmVyXTogU2xhRGF0YTtcbn1cblxuZXhwb3J0IHR5cGUgQ2FyZEFjdGlvbiA9IENyZWF0ZUNhcmRBY3Rpb24gfCBVcGRhdGVDYXJkQWN0aW9uIHwgQ29weUNhcmRBY3Rpb24gfCBFbWFpbENhcmRBY3Rpb247XG5cbmV4cG9ydCB0eXBlIFVwZGF0ZUNhcmRBY3Rpb24gPSB7XG4gICAgZGF0YToge1xuICAgICAgICBsaXN0QWZ0ZXI6IHtpZDogc3RyaW5nfTtcbiAgICAgICAgbGlzdEJlZm9yZToge2lkOiBzdHJpbmd9O1xuICAgICAgICBjYXJkOiBOYW1lQW5kSWQ7XG4gICAgfTtcbiAgICB0eXBlOiB0eXBlb2YgQ2FyZEFjdGlvblR5cGUudXBkYXRlQ2FyZDtcbiAgICBkYXRlOiBzdHJpbmc7IC8vIGZvcm1hdCAyMDE5LTExLTI5VDIxOjA1OjI4LjUxMFpcbn1cblxuZXhwb3J0IHR5cGUgQ3JlYXRlQ2FyZEFjdGlvbiA9IHtcbiAgICBkYXRhOiB7XG4gICAgICAgIGxpc3Q6IHtpZDogc3RyaW5nfTtcbiAgICAgICAgY2FyZDogTmFtZUFuZElkO1xuICAgIH07XG4gICAgdHlwZTogdHlwZW9mIENhcmRBY3Rpb25UeXBlLmNyZWF0ZUNhcmQ7XG4gICAgZGF0ZTogc3RyaW5nOyAvLyBmb3JtYXQgMjAxOS0xMS0yOVQyMTowNToyOC41MTBaXG59XG5cbmV4cG9ydCB0eXBlIENvcHlDYXJkQWN0aW9uID0ge1xuICAgIGRhdGE6IHtcbiAgICAgICAgbGlzdDoge2lkOiBzdHJpbmd9O1xuICAgICAgICBjYXJkOiBOYW1lQW5kSWQ7XG4gICAgfTtcbiAgICB0eXBlOiB0eXBlb2YgQ2FyZEFjdGlvblR5cGUuY29weUNhcmQ7XG4gICAgZGF0ZTogc3RyaW5nOyAvLyBmb3JtYXQgMjAxOS0xMS0yOVQyMTowNToyOC41MTBaXG59O1xuXG5cbi8vIFRPRE86IEkgZG9uJ3QgYWN0dWFsbHkga25vdyB0aGUgZGF0YXNoYXBlIG9mIGVtYWlsIGFjdGlvbnMsIGJ1dCB3b3VsZCBhc3N1bWUgaXQgaXMgdGhpc1xuZXhwb3J0IHR5cGUgRW1haWxDYXJkQWN0aW9uID0ge1xuICAgIGRhdGE6IHtcbiAgICAgICAgbGlzdDoge2lkOiBzdHJpbmd9O1xuICAgICAgICBjYXJkOiBOYW1lQW5kSWQ7XG4gICAgfTtcbiAgICB0eXBlOiB0eXBlb2YgQ2FyZEFjdGlvblR5cGUuZW1haWxDYXJkO1xuICAgIGRhdGU6IHN0cmluZzsgLy8gZm9ybWF0IDIwMTktMTEtMjlUMjE6MDU6MjguNTEwWlxufTtcblxudHlwZSBOYW1lQW5kSWQgPSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIExpc3QgPSBOYW1lQW5kSWQ7XG5cbmV4cG9ydCB0eXBlIEJvYXJkQWN0aW9uID0ge1xuICAgIGRhdGE6IHtcbiAgICAgICAgYm9hcmQ6IE5hbWVBbmRJZDtcbiAgICAgICAgY2FyZDogTmFtZUFuZElkO1xuICAgICAgICBsaXN0PzogTmFtZUFuZElkO1xuICAgICAgICBsaXN0QmVmb3JlPzogTmFtZUFuZElkO1xuICAgICAgICBsaXN0QWZ0ZXI/OiBOYW1lQW5kSWQ7XG4gICAgfTtcbiAgICBkYXRlOiBzdHJpbmc7XG4gICAgdHlwZTogQ2FyZEFjdGlvblR5cGU7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb25maWd1cmF0aW9ucyA9ICh0KTogUHJvbWlzZTxTbGFDb25maWd1cmF0aW9uW10gfCB2b2lkPiA9PiB0LmdldCgnYm9hcmQnLCAnc2hhcmVkJywgJ2NvbmZpZycpO1xuZXhwb3J0IGNvbnN0IHNldENvbmZpZ3VyYXRpb25zID0gKHQsIGNvbmZpZzogU2xhQ29uZmlndXJhdGlvbltdKTogdm9pZCA9PiB0LnNldCgnYm9hcmQnLCAnc2hhcmVkJywgJ2NvbmZpZycsIGNvbmZpZyk7XG5leHBvcnQgY29uc3QgZ2V0U2xhRGF0YSA9ICh0KTogUHJvbWlzZTxTbGFEYXRhTWFwIHwgdm9pZD4gPT4gdC5nZXQoJ2NhcmQnLCAnc2hhcmVkJywgJ3NsYURhdGEnKTtcbmV4cG9ydCBjb25zdCBzZXRTbGFEYXRhID0gKHQsIHNsYURhdGE6IFNsYURhdGFNYXApOiB2b2lkID0+IHQuc2V0KCdjYXJkJywgJ3NoYXJlZCcsICdzbGFEYXRhJywgc2xhRGF0YSk7XG5leHBvcnQgY29uc3QgZ2V0VG9rZW4gPSAodCk6IFByb21pc2U8c3RyaW5nIHwgdm9pZD4gPT4gdC5nZXQoJ21lbWJlcicsICdwcml2YXRlJywgJ2F1dGhUb2tlbicpO1xuZXhwb3J0IGNvbnN0IHNldFRva2VuID0gKHQsIHRva2VuKTogUHJvbWlzZTx2b2lkPiA9PiB0LnNldCgnbWVtYmVyJywgJ3ByaXZhdGUnLCAnYXV0aFRva2VuJywgdG9rZW4pO1xuXG4vKipcbiAqIFRPRE86IHRoZSBwcm9ibGVtIHdpdGggZ2V0dGluZyBhbGwgYm9hcmQgYWN0aW9ucyBpcyB0aGF0IHRoZXJlIGlzIGEgbGltaXQgb2YgMTAwMFxuICogQW5kIHRoYXQgdGhlIGFjdGlvbnMgZm9yIGNsb3NlZCBjYXJkcyBhcmUgYWxzbyBjb3VudGVkLlxuICovIFxuZXhwb3J0IGNvbnN0IGdldEJvYXJkQWN0aW9ucyA9IGFzeW5jICh0KTogUHJvbWlzZTxCb2FyZEFjdGlvbltdPiA9PiB7XG4gICAgY29uc3QgeyBib2FyZDogYm9hcmRJZCB9ID0gdC5nZXRDb250ZXh0KCk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRUb2tlbih0KTtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9hcGkudHJlbGxvLmNvbS8xL2JvYXJkcy8ke2JvYXJkSWR9L2FjdGlvbnM/bGltaXQ9MTAwMCZmaWx0ZXI9dXBkYXRlQ2FyZDppZExpc3QsY3JlYXRlQ2FyZCZtZW1iZXI9ZmFsc2UmbWVtYmVyQ3JlYXRvcj1mYWxzZSZrZXk9JHtrZXl9JnRva2VuPSR7dG9rZW59YDtcbiAgICByZXR1cm4gYXhpb3MuZ2V0KHVybClcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5yZXNwb25zZSAmJiBlLnJlc3BvbnNlLnN0YXR1cyAmJiBlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgc2V0VG9rZW4odCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59O1xuXG5cbmV4cG9ydCBjb25zdCBnZXRDYXJkQWN0aW9ucyA9IGFzeW5jICh0KTogUHJvbWlzZTxDYXJkQWN0aW9uW10+ID0+IHtcbiAgICBjb25zdCB7IGNhcmQ6IGNhcmRJZCB9ID0gdC5nZXRDb250ZXh0KCk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRUb2tlbih0KTtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9hcGkudHJlbGxvLmNvbS8xL2NhcmRzLyR7Y2FyZElkfS9hY3Rpb25zP2ZpbHRlcj11cGRhdGVDYXJkOmlkTGlzdCxjcmVhdGVDYXJkJmtleT0ke2tleX0mdG9rZW49JHt0b2tlbn1gO1xuICAgIHJldHVybiBheGlvcy5nZXQodXJsKS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmRhdGEpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlICYmIGUucmVzcG9uc2UgJiYgZS5yZXNwb25zZS5zdGF0dXMgJiYgZS5yZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgc2V0VG9rZW4odCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldExpc3RzID0gYXN5bmMgKHQpOiBQcm9taXNlPExpc3RbXT4gPT4ge1xuICAgIGNvbnN0IHsgYm9hcmQ6IGJvYXJkSWQgfSA9IHQuZ2V0Q29udGV4dCgpO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0VG9rZW4odCk7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vYXBpLnRyZWxsby5jb20vMS9ib2FyZHMvJHtib2FyZElkfS9saXN0cz9jYXJkcz1ub25lJmZpbHRlcj1vcGVuJmtleT0ke2tleX0mdG9rZW49JHt0b2tlbn1gO1xuICAgIHJldHVybiBheGlvcy5nZXQodXJsKS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmRhdGEpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlICYmIGUucmVzcG9uc2UgJiYgZS5yZXNwb25zZS5zdGF0dXMgJiYgZS5yZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgc2V0VG9rZW4odCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/trello-util.ts\n");

/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/*! exports provided: truncate, getHumanReadableTime, getMinutesRemaining, getColor, getRunningSlas, getEndTime, getStartTime, getUpdatedSlaData, updateConfigs, getActionsPerCard, generateUuid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"truncate\", function() { return truncate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHumanReadableTime\", function() { return getHumanReadableTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMinutesRemaining\", function() { return getMinutesRemaining; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getColor\", function() { return getColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRunningSlas\", function() { return getRunningSlas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getEndTime\", function() { return getEndTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStartTime\", function() { return getStartTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUpdatedSlaData\", function() { return getUpdatedSlaData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateConfigs\", function() { return updateConfigs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getActionsPerCard\", function() { return getActionsPerCard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateUuid\", function() { return generateUuid; });\n/* harmony import */ var _trello_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trello-util */ \"./src/trello-util.ts\");\n\nconst truncate = (str, n, shouldEllipse) => (str.length > n) ? str.substr(0, n - 1) + `${shouldEllipse ? '&hellip;' : ''}` : str;\nconst getHumanReadableTime = (realMinutes) => {\n    const isNegative = realMinutes < 0;\n    const minutes = isNegative ? realMinutes * -1 : realMinutes;\n    const negativeSign = isNegative ? '-' : '';\n    const MINUTES = 'min';\n    const HOURS = 'h';\n    const DAYS = 'd';\n    if (minutes < 60) {\n        return `${negativeSign}${minutes}${MINUTES}`;\n    }\n    if (minutes < 1440) {\n        const hours = Math.floor(minutes / 60);\n        const hoursString = hours > 0 ? `${hours}${HOURS}` : '';\n        const remainingMinutes = minutes - 60 * hours;\n        const minutesString = remainingMinutes > 0 ? `${remainingMinutes}${MINUTES}` : '';\n        const spacer = hoursString && minutesString ? ' ' : '';\n        return `${negativeSign}${hoursString}${spacer}${minutesString}`;\n    }\n    const days = Math.floor(minutes / 1440);\n    const daysString = days > 0 ? `${days}${DAYS}` : '';\n    const remainingMinutes = minutes - days * 1440;\n    const remainingHours = Math.floor(remainingMinutes / 60);\n    const hoursString = remainingHours > 0 ? `${remainingHours}${HOURS}` : '';\n    const spacer = daysString && hoursString ? ' ' : '';\n    return `${negativeSign}${daysString}${spacer}${hoursString}`;\n};\nconst getMinutesRemaining = (startTime, maybeEndTime, config) => {\n    const endTime = maybeEndTime ? maybeEndTime : moment().valueOf();\n    const minutesElapsed = Math.floor((endTime - startTime) / 1000 / 60);\n    const minutesRemaining = config.time - minutesElapsed;\n    return minutesRemaining;\n};\nconst getColor = (minutesRemaining, isComplete) => {\n    if (isComplete) {\n        return 'grey';\n    }\n    ;\n    if (minutesRemaining < 0) {\n        return 'red';\n    }\n    else if (minutesRemaining < 60) {\n        return 'yellow';\n    }\n    return 'green';\n};\nconst getRunningSlas = (data, configs, detailed) => {\n    const runningSlas = [];\n    const completeSlas = [];\n    configs.forEach((config) => {\n        if (data[config.id]) {\n            const { startTime, endTime } = data[config.id];\n            if (startTime && !endTime) {\n                runningSlas.push({\n                    dynamic: function () {\n                        const minutesRemaining = getMinutesRemaining(startTime, endTime, config);\n                        const humanReadable = getHumanReadableTime(minutesRemaining);\n                        return Object.assign(Object.assign(Object.assign({ text: humanReadable, color: getColor(minutesRemaining, false) }, (detailed ? { title: `${config.name} - Ongoing` } : {})), (!detailed ? { icon: `${window.location}img/stopwatch.svg` } : {})), { refresh: 60 });\n                    }\n                });\n            }\n            if (startTime && endTime && detailed) {\n                const minutesRemaining = getMinutesRemaining(startTime, endTime, config);\n                const humanReadable = getHumanReadableTime(minutesRemaining);\n                completeSlas.push({\n                    text: humanReadable,\n                    color: getColor(minutesRemaining, true),\n                    title: `${config.name} - stopped`,\n                });\n            }\n        }\n    });\n    // We want the complete SLAs to come after the running ones\n    const allSlas = runningSlas.concat(completeSlas);\n    return allSlas;\n};\nconst getEndTime = (actions, endCondition, startTime) => {\n    let endTime = undefined;\n    actions.forEach((action) => {\n        if (action.type === _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"CardActionType\"].updateCard) {\n            if (action.data.listAfter.id === endCondition.id &&\n                (!endTime || moment(action.date).valueOf() < endTime) &&\n                moment(action.date).valueOf() > startTime) {\n                endTime = moment(action.date).valueOf();\n            }\n        }\n    });\n    return endTime;\n};\nconst getStartTime = (actions, startCondition) => {\n    let startTime = undefined;\n    actions.forEach((action) => {\n        if ((action.type === _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"CardActionType\"].createCard || action.type === _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"CardActionType\"].copyCard || action.type === _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"CardActionType\"].emailCard)\n            && action.data.list.id === startCondition.id) {\n            startTime = moment(action.date).valueOf();\n        }\n        else if (action.type === _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"CardActionType\"].updateCard &&\n            action.data.listAfter.id === startCondition.id &&\n            !startTime || (moment(action.date).valueOf() < startTime)) {\n            startTime = moment(action.date).valueOf();\n        }\n    });\n    return startTime;\n};\nconst getUpdatedSlaData = (actions, configs, slaMap) => {\n    const updatedSlaMap = slaMap;\n    let hasChanged = false;\n    configs.forEach(config => {\n        const { id, startCondition, endCondition } = config;\n        if (!updatedSlaMap[id]) {\n            updatedSlaMap[id] = {};\n        }\n        const { startTime = undefined, endTime = undefined } = updatedSlaMap[id];\n        // We always recalculate start times and end times, in case the config has been edited.\n        const newStartTime = getStartTime(actions, startCondition);\n        const startTimeHasChanged = newStartTime !== startTime;\n        const newEndTime = startTime || newStartTime ? getEndTime(actions, endCondition, startTime || newStartTime) : undefined;\n        const endTimeHasChanged = newEndTime !== endTime;\n        if (startTimeHasChanged) {\n            hasChanged = true;\n            updatedSlaMap[id].startTime = newStartTime;\n        }\n        if (endTimeHasChanged) {\n            hasChanged = true;\n            updatedSlaMap[id].endTime = newEndTime;\n        }\n    });\n    return hasChanged ? updatedSlaMap : undefined;\n};\n// Find and remove any data from configs that have been since-deleted\nconst getSlaDataWithRemovals = (configs, slaMap) => {\n    const keys = Object.keys(slaMap);\n    if (keys.length === 0) {\n        return undefined;\n    }\n    const configIds = configs.map(config => config.id);\n    let removed = undefined;\n    keys.forEach(key => {\n        if (configIds.indexOf(key) === -1) {\n            removed = true;\n            delete slaMap[key];\n        }\n    });\n    return removed ? slaMap : undefined;\n};\nconst updateConfigs = (t, configs, slaMap) => {\n    Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getCardActions\"])(t).then((actions) => {\n        const updatedSlaData = getUpdatedSlaData(actions, configs, slaMap);\n        if (updatedSlaData) {\n            const slaDataWithRemovals = getSlaDataWithRemovals(configs, updatedSlaData);\n            const result = slaDataWithRemovals ? slaDataWithRemovals : updatedSlaData;\n            Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"setSlaData\"])(t, result);\n        }\n        else {\n            const slaDataWithRemovals = getSlaDataWithRemovals(configs, slaMap);\n            if (slaDataWithRemovals) {\n                Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"setSlaData\"])(t, slaDataWithRemovals);\n            }\n        }\n    });\n};\nconst getActionsPerCard = (actions) => {\n    const map = {};\n    actions.forEach(action => {\n        if (map[action.data.card.id] === undefined) {\n            map[action.data.card.id] = [];\n        }\n        map[action.data.card.id].push(action);\n    });\n    return map;\n};\n// https://gist.github.com/jed/982883\nconst generateUuid = function () { return (\"\" + 1e7 + -1e3 + -4e3 + -8e3 + -1e11).replace(/1|0/g, function () { return (0 | Math.random() * 16).toString(16); }); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdXRpbC50cz80OTU2Il0sInNvdXJjZXNDb250ZW50IjpbImRlY2xhcmUgY29uc3QgbW9tZW50OiBhbnk7XG5cbmltcG9ydCB7IHNldFNsYURhdGEsIFNsYURhdGFNYXAsIFNsYUNvbmZpZ3VyYXRpb24sIGdldENhcmRBY3Rpb25zLCBDYXJkQWN0aW9uLCBDYXJkQWN0aW9uVHlwZSwgU2xhQ29uZGl0aW9uLCBCb2FyZEFjdGlvbiB9IGZyb20gJy4vdHJlbGxvLXV0aWwnO1xuXG50eXBlIENhcmRCYWRnZSA9IHtcbiAgdGV4dDogc3RyaW5nO1xuICBjb2xvcjogc3RyaW5nO1xuICByZWZyZXNoOiBudW1iZXI7XG4gIGljb24/OiBzdHJpbmc7XG4gIHRpdGxlPzogc3RyaW5nO1xufTtcblxudHlwZSBDYXJkRGV0YWlsZWRCYWRnZSA9IHtcbiAgdGl0bGU6IHN0cmluZztcbiAgY29sb3I6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICBjYWxsYmFjaz86ICgpID0+IHt9O1xufTtcblxuZXhwb3J0IGNvbnN0IHRydW5jYXRlID0gKHN0cjogc3RyaW5nLCBuOiBudW1iZXIsIHNob3VsZEVsbGlwc2U6IGJvb2xlYW4pOiBzdHJpbmcgPT5cbiAgICAoc3RyLmxlbmd0aCA+IG4pID8gc3RyLnN1YnN0cigwLCBuLTEpICsgYCR7c2hvdWxkRWxsaXBzZSA/ICcmaGVsbGlwOycgOiAnJ31gIDogc3RyO1xuXG5leHBvcnQgY29uc3QgZ2V0SHVtYW5SZWFkYWJsZVRpbWUgPSAocmVhbE1pbnV0ZXM6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9IHJlYWxNaW51dGVzIDwgMDtcbiAgICBjb25zdCBtaW51dGVzID0gaXNOZWdhdGl2ZSA/IHJlYWxNaW51dGVzICogLTEgOiByZWFsTWludXRlcztcbiAgICBjb25zdCBuZWdhdGl2ZVNpZ24gPSBpc05lZ2F0aXZlID8gJy0nIDogJyc7XG5cbiAgICBjb25zdCBNSU5VVEVTID0gJ21pbic7XG4gICAgY29uc3QgSE9VUlMgPSAnaCc7XG4gICAgY29uc3QgREFZUyA9ICdkJztcblxuICAgIGlmIChtaW51dGVzIDwgNjApIHtcbiAgICAgICAgcmV0dXJuIGAke25lZ2F0aXZlU2lnbn0ke21pbnV0ZXN9JHtNSU5VVEVTfWA7XG4gICAgfSBpZiAobWludXRlcyA8IDE0NDApIHtcbiAgICAgICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGNvbnN0IGhvdXJzU3RyaW5nID0gaG91cnMgPiAwID8gYCR7aG91cnN9JHtIT1VSU31gIDogJyc7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ01pbnV0ZXMgPSBtaW51dGVzIC0gNjAgKiBob3VycztcbiAgICAgICAgY29uc3QgbWludXRlc1N0cmluZyA9IHJlbWFpbmluZ01pbnV0ZXMgPiAwID8gYCR7cmVtYWluaW5nTWludXRlc30ke01JTlVURVN9YCA6ICcnO1xuICAgICAgICBjb25zdCBzcGFjZXIgPSBob3Vyc1N0cmluZyAmJiBtaW51dGVzU3RyaW5nID8gJyAnIDogJyc7XG4gICAgICAgIHJldHVybiBgJHtuZWdhdGl2ZVNpZ259JHtob3Vyc1N0cmluZ30ke3NwYWNlcn0ke21pbnV0ZXNTdHJpbmd9YDtcbiAgICB9IFxuICAgIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyAxNDQwKTtcbiAgICBjb25zdCBkYXlzU3RyaW5nID0gZGF5cyA+IDAgPyBgJHtkYXlzfSR7REFZU31gIDogJyc7XG4gICAgY29uc3QgcmVtYWluaW5nTWludXRlcyA9IG1pbnV0ZXMgLSBkYXlzICogMTQ0MDtcbiAgICBjb25zdCByZW1haW5pbmdIb3VycyA9IE1hdGguZmxvb3IocmVtYWluaW5nTWludXRlcyAvIDYwKTsgXG4gICAgY29uc3QgaG91cnNTdHJpbmcgPSByZW1haW5pbmdIb3VycyA+IDAgPyBgJHtyZW1haW5pbmdIb3Vyc30ke0hPVVJTfWAgOiAnJztcbiAgICBjb25zdCBzcGFjZXIgPSBkYXlzU3RyaW5nICYmIGhvdXJzU3RyaW5nID8gJyAnIDogJyc7XG4gICAgcmV0dXJuIGAke25lZ2F0aXZlU2lnbn0ke2RheXNTdHJpbmd9JHtzcGFjZXJ9JHtob3Vyc1N0cmluZ31gO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldE1pbnV0ZXNSZW1haW5pbmcgPSAoc3RhcnRUaW1lOiBudW1iZXIsIG1heWJlRW5kVGltZTogbnVtYmVyIHwgdm9pZCwgY29uZmlnOiBTbGFDb25maWd1cmF0aW9uKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCBlbmRUaW1lID0gbWF5YmVFbmRUaW1lID8gbWF5YmVFbmRUaW1lIDogbW9tZW50KCkudmFsdWVPZigpO1xuICAgIGNvbnN0IG1pbnV0ZXNFbGFwc2VkID0gTWF0aC5mbG9vcigoZW5kVGltZSAtIHN0YXJ0VGltZSkgLyAxMDAwIC8gNjApO1xuICAgIGNvbnN0IG1pbnV0ZXNSZW1haW5pbmcgPSBjb25maWcudGltZSAtIG1pbnV0ZXNFbGFwc2VkO1xuICAgIHJldHVybiBtaW51dGVzUmVtYWluaW5nO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENvbG9yID0gKG1pbnV0ZXNSZW1haW5pbmc6IG51bWJlciwgaXNDb21wbGV0ZTogYm9vbGVhbik6IHN0cmluZyA9PiB7XG4gICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuICdncmV5JztcbiAgICB9O1xuXG4gICAgaWYgKG1pbnV0ZXNSZW1haW5pbmcgPCAwKSB7XG4gICAgICAgIHJldHVybiAncmVkJztcbiAgICB9IGVsc2UgaWYgKG1pbnV0ZXNSZW1haW5pbmcgPCA2MCkge1xuICAgICAgICByZXR1cm4gJ3llbGxvdyc7XG4gICAgfVxuICAgIHJldHVybiAnZ3JlZW4nO1xufTtcblxudHlwZSBEeW5hbWljQmFkZ2UgPSB7XG4gIGR5bmFtaWM6ICgpID0+IENhcmRCYWRnZTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRSdW5uaW5nU2xhcyA9IChkYXRhOiBTbGFEYXRhTWFwLCBjb25maWdzOiBTbGFDb25maWd1cmF0aW9uW10sIGRldGFpbGVkOiBib29sZWFuKTogQ2FyZEJhZGdlW10gfCBDYXJkRGV0YWlsZWRCYWRnZVtdIHwgRHluYW1pY0JhZGdlW10gPT4ge1xuICAgIGNvbnN0IHJ1bm5pbmdTbGFzID0gW107XG4gICAgY29uc3QgY29tcGxldGVTbGFzID0gW107XG4gIFxuICAgIGNvbmZpZ3MuZm9yRWFjaCgoY29uZmlnKSA9PiB7XG4gICAgICAgIGlmIChkYXRhW2NvbmZpZy5pZF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRUaW1lLCBlbmRUaW1lIH0gPSBkYXRhW2NvbmZpZy5pZF07XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lICYmICFlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ1NsYXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWludXRlc1JlbWFpbmluZyA9IGdldE1pbnV0ZXNSZW1haW5pbmcoc3RhcnRUaW1lLCBlbmRUaW1lLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHVtYW5SZWFkYWJsZSA9IGdldEh1bWFuUmVhZGFibGVUaW1lKG1pbnV0ZXNSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBodW1hblJlYWRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRDb2xvcihtaW51dGVzUmVtYWluaW5nLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGRldGFpbGVkID8geyB0aXRsZTogYCR7Y29uZmlnLm5hbWV9IC0gT25nb2luZ2AgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oIWRldGFpbGVkID8ge2ljb246IGAke3dpbmRvdy5sb2NhdGlvbn1pbWcvc3RvcHdhdGNoLnN2Z2B9IDoge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2g6IDYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lICYmIGVuZFRpbWUgJiYgZGV0YWlsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW51dGVzUmVtYWluaW5nID0gZ2V0TWludXRlc1JlbWFpbmluZyhzdGFydFRpbWUsIGVuZFRpbWUsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaHVtYW5SZWFkYWJsZSA9IGdldEh1bWFuUmVhZGFibGVUaW1lKG1pbnV0ZXNSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlU2xhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaHVtYW5SZWFkYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGdldENvbG9yKG1pbnV0ZXNSZW1haW5pbmcsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYCR7Y29uZmlnLm5hbWV9IC0gc3RvcHBlZGAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gV2Ugd2FudCB0aGUgY29tcGxldGUgU0xBcyB0byBjb21lIGFmdGVyIHRoZSBydW5uaW5nIG9uZXNcbiAgICBjb25zdCBhbGxTbGFzID0gcnVubmluZ1NsYXMuY29uY2F0KGNvbXBsZXRlU2xhcyk7XG4gICAgXG4gICAgcmV0dXJuIGFsbFNsYXM7XG59O1xuXG5cblxuZXhwb3J0IGNvbnN0IGdldEVuZFRpbWUgPSAoYWN0aW9uczogQ2FyZEFjdGlvbltdLCBlbmRDb25kaXRpb246IFNsYUNvbmRpdGlvbiwgc3RhcnRUaW1lOiBudW1iZXIpOiBudW1iZXIgfCB2b2lkID0+IHtcbiAgICBsZXQgZW5kVGltZTogbnVtYmVyIHwgdm9pZCA9IHVuZGVmaW5lZDtcbiAgICBhY3Rpb25zLmZvckVhY2goKGFjdGlvbikgPT4ge1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IENhcmRBY3Rpb25UeXBlLnVwZGF0ZUNhcmQpIHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uZGF0YS5saXN0QWZ0ZXIuaWQgPT09IGVuZENvbmRpdGlvbi5pZCAmJlxuICAgICAgICAoIWVuZFRpbWUgfHwgbW9tZW50KGFjdGlvbi5kYXRlKS52YWx1ZU9mKCkgPCBlbmRUaW1lKSAgJiYgXG4gICAgICAgIG1vbWVudChhY3Rpb24uZGF0ZSkudmFsdWVPZigpID4gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZW5kVGltZSA9IG1vbWVudChhY3Rpb24uZGF0ZSkudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW5kVGltZTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdGFydFRpbWUgPSAoYWN0aW9uczogQ2FyZEFjdGlvbltdLCBzdGFydENvbmRpdGlvbjogU2xhQ29uZGl0aW9uKTogbnVtYmVyIHwgdm9pZCA9PiB7XG4gICAgbGV0IHN0YXJ0VGltZTogbnVtYmVyIHwgdm9pZCA9IHVuZGVmaW5lZDtcblxuICAgIGFjdGlvbnMuZm9yRWFjaCgoYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmICgoYWN0aW9uLnR5cGUgPT09IENhcmRBY3Rpb25UeXBlLmNyZWF0ZUNhcmQgfHwgYWN0aW9uLnR5cGUgPT09IENhcmRBY3Rpb25UeXBlLmNvcHlDYXJkIHx8IGFjdGlvbi50eXBlID09PSBDYXJkQWN0aW9uVHlwZS5lbWFpbENhcmQpXG4gICAgICAgICAmJiBhY3Rpb24uZGF0YS5saXN0LmlkID09PSBzdGFydENvbmRpdGlvbi5pZCkge1xuICAgICAgICAgICAgc3RhcnRUaW1lID0gbW9tZW50KGFjdGlvbi5kYXRlKS52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09IENhcmRBY3Rpb25UeXBlLnVwZGF0ZUNhcmQgJiZcbiAgICAgIGFjdGlvbi5kYXRhLmxpc3RBZnRlci5pZCA9PT0gc3RhcnRDb25kaXRpb24uaWQgJiZcbiAgICAgICFzdGFydFRpbWUgfHwgKG1vbWVudChhY3Rpb24uZGF0ZSkudmFsdWVPZigpIDwgc3RhcnRUaW1lKSkge1xuICAgICAgICAgICAgc3RhcnRUaW1lID0gbW9tZW50KGFjdGlvbi5kYXRlKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzdGFydFRpbWU7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXBkYXRlZFNsYURhdGEgPSAoYWN0aW9uczogQ2FyZEFjdGlvbltdLCBjb25maWdzOiBTbGFDb25maWd1cmF0aW9uW10sIHNsYU1hcDogU2xhRGF0YU1hcCk6IFNsYURhdGFNYXAgfCB2b2lkID0+IHtcbiAgICBjb25zdCB1cGRhdGVkU2xhTWFwID0gc2xhTWFwO1xuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBjb25maWdzLmZvckVhY2goY29uZmlnID0+IHtcbiAgICAgICAgY29uc3QgeyBpZCwgc3RhcnRDb25kaXRpb24sIGVuZENvbmRpdGlvbiB9ID0gY29uZmlnO1xuXG4gICAgICAgIGlmICghdXBkYXRlZFNsYU1hcFtpZF0pIHtcbiAgICAgICAgICAgIHVwZGF0ZWRTbGFNYXBbaWRdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXJ0VGltZSA9IHVuZGVmaW5lZCwgZW5kVGltZSA9IHVuZGVmaW5lZCB9ID0gdXBkYXRlZFNsYU1hcFtpZF07XG5cbiAgICAgICAgLy8gV2UgYWx3YXlzIHJlY2FsY3VsYXRlIHN0YXJ0IHRpbWVzIGFuZCBlbmQgdGltZXMsIGluIGNhc2UgdGhlIGNvbmZpZyBoYXMgYmVlbiBlZGl0ZWQuXG4gICAgICAgIGNvbnN0IG5ld1N0YXJ0VGltZSA9IGdldFN0YXJ0VGltZShhY3Rpb25zLCBzdGFydENvbmRpdGlvbik7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZUhhc0NoYW5nZWQ6IGJvb2xlYW4gPSBuZXdTdGFydFRpbWUgIT09IHN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgbmV3RW5kVGltZSA9IHN0YXJ0VGltZSB8fCBuZXdTdGFydFRpbWUgPyBnZXRFbmRUaW1lKGFjdGlvbnMsIGVuZENvbmRpdGlvbiwgc3RhcnRUaW1lIHx8IG5ld1N0YXJ0VGltZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGVuZFRpbWVIYXNDaGFuZ2VkOiBib29sZWFuID0gbmV3RW5kVGltZSAhPT0gZW5kVGltZTtcbiAgICBcbiAgICAgICAgaWYgKHN0YXJ0VGltZUhhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdXBkYXRlZFNsYU1hcFtpZF0uc3RhcnRUaW1lID0gbmV3U3RhcnRUaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZFRpbWVIYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHVwZGF0ZWRTbGFNYXBbaWRdLmVuZFRpbWUgPSBuZXdFbmRUaW1lO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IHVwZGF0ZWRTbGFNYXAgOiB1bmRlZmluZWQ7XG59O1xuXG4vLyBGaW5kIGFuZCByZW1vdmUgYW55IGRhdGEgZnJvbSBjb25maWdzIHRoYXQgaGF2ZSBiZWVuIHNpbmNlLWRlbGV0ZWRcbmNvbnN0IGdldFNsYURhdGFXaXRoUmVtb3ZhbHMgPSAoY29uZmlnczogU2xhQ29uZmlndXJhdGlvbltdLCBzbGFNYXA6IFNsYURhdGFNYXApOiBTbGFEYXRhTWFwIHwgdm9pZCA9PiB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNsYU1hcCk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZ0lkcyA9IGNvbmZpZ3MubWFwKGNvbmZpZyA9PiBjb25maWcuaWQpO1xuXG4gICAgbGV0IHJlbW92ZWQgPSB1bmRlZmluZWQ7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChjb25maWdJZHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGUgc2xhTWFwW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZW1vdmVkID8gc2xhTWFwIDogdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUNvbmZpZ3MgPSAodDogYW55LCBjb25maWdzOiBTbGFDb25maWd1cmF0aW9uW10sIHNsYU1hcDogU2xhRGF0YU1hcCk6IHZvaWQgPT4ge1xuICAgIGdldENhcmRBY3Rpb25zKHQpLnRoZW4oKGFjdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFNsYURhdGEgPSBnZXRVcGRhdGVkU2xhRGF0YShhY3Rpb25zLCBjb25maWdzLCBzbGFNYXApO1xuICAgICAgICBpZiAodXBkYXRlZFNsYURhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsYURhdGFXaXRoUmVtb3ZhbHMgPSBnZXRTbGFEYXRhV2l0aFJlbW92YWxzKGNvbmZpZ3MsIHVwZGF0ZWRTbGFEYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNsYURhdGFXaXRoUmVtb3ZhbHMgPyBzbGFEYXRhV2l0aFJlbW92YWxzIDogdXBkYXRlZFNsYURhdGE7XG4gICAgICAgICAgICBzZXRTbGFEYXRhKHQsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzbGFEYXRhV2l0aFJlbW92YWxzID0gZ2V0U2xhRGF0YVdpdGhSZW1vdmFscyhjb25maWdzLCBzbGFNYXApO1xuICAgICAgICAgICAgaWYgKHNsYURhdGFXaXRoUmVtb3ZhbHMpIHtcbiAgICAgICAgICAgICAgICBzZXRTbGFEYXRhKHQsIHNsYURhdGFXaXRoUmVtb3ZhbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QWN0aW9uc1BlckNhcmQgPSAoYWN0aW9uczogQm9hcmRBY3Rpb25bXSk6IHtba2V5OiBzdHJpbmddOiBDYXJkQWN0aW9uW119ID0+IHtcbiAgICBjb25zdCBtYXAgPSB7fTtcbiAgICBhY3Rpb25zLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgaWYgKG1hcFthY3Rpb24uZGF0YS5jYXJkLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXBbYWN0aW9uLmRhdGEuY2FyZC5pZF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtYXBbYWN0aW9uLmRhdGEuY2FyZC5pZF0ucHVzaChhY3Rpb24pO1xuICAgIH0pO1xuICBcbiAgICByZXR1cm4gbWFwO1xufTtcblxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlVXVpZCA9IGZ1bmN0aW9uICgpOiBzdHJpbmcgeyByZXR1cm4gKFwiXCIgKyAxZTcgKyAtMWUzICsgLTRlMyArIC04ZTMgKyAtMWUxMSkucmVwbGFjZSgvMXwwL2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuICgwIHwgTWF0aC5yYW5kb20oKSAqIDE2KS50b1N0cmluZygxNik7IH0pOyB9O1xuIl0sIm1hcHBpbmdzIjoiQUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/util.ts\n");

/***/ })

/******/ });