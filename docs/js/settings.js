/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/settings.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/settings.ts":
/*!*************************!*\
  !*** ./src/settings.ts ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _trello_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trello-util */ \"./src/trello-util.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst t = TrelloPowerUp.iframe();\n\n\nlet lists = [];\nconst START_SELECT = '.start-select';\nconst END_SELECT = '.end-select';\nconst HOURS_INPUT = '.hours-input';\nconst MINUTES_INPUT = '.minutes-input';\nconst NAME_INPUT = '.name-input';\nconst stringToNode = (domString) => {\n    const wrapper = document.createElement('div');\n    wrapper.innerHTML = domString;\n    return wrapper.firstChild;\n};\nconst columnIdToName = (id) => {\n    const list = lists.find(list => list.id === id);\n    return list ? list.name : '<i>List no longer exists</i>';\n};\nconst createOptions = (currentValue, filteredValue) => {\n    const options = [];\n    lists.forEach(list => {\n        if (list.id !== filteredValue) {\n            const option = document.createElement('option');\n            option.setAttribute('value', list.id);\n            option.appendChild(document.createTextNode(list.name));\n            if (list.id === currentValue) {\n                option.selected = true;\n            }\n            options.push(option);\n        }\n    });\n    return options;\n};\nconst createOptionsForNewRow = (isStart) => isStart ? createOptions(lists[0].id, lists[1].id) : createOptions(lists[1].id, lists[0].id);\nconst getConfigString = (config, withRowDiv = true) => `${withRowDiv ? '<div class=\"row clickable\">' : ''}\n      <div class=\"col0\">${Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"truncate\"])(config.name, 40, true)}</div>\n      <div class=\"col1\">\n        <span class=\"condition-type\">Start when card is in list</span>\n        <br>${Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"truncate\"])(columnIdToName(config.startCondition.id), 20, true)}\n        <br><span class=\"condition-type\">Ends when card is in list</span>\n        <br>${columnIdToName(config.endCondition.id)}\n      </div>\n      <div class=\"col2\">Duration: ${Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"getHumanReadableTime\"])(config.time)}</div>\n      <div class=\"col3\"><button id=\"delete-btn\" class=\"mod-bottom\">Delete</button></div>\n  ${withRowDiv ? '</div>' : ''}`;\nconst renderConfig = (config, withRowDiv = true) => stringToNode(getConfigString(config, withRowDiv));\nconst getConfigEditMode = (config) => {\n    const domString = `\n    <div class=\"col0\">\n      <input class=\"name-input\" value=${config ? `\"${config.name}\"` : \"SLA Name\"}></input>\n    </div>\n    <div class=\"col1\">\n      <span class=\"condition-type\">Start when card is in list</span>\n      <br><select class=\"start-select\"></select>\n      <br><span class=\"condition-type\">End when card is in list</span>\n      <br><select class=\"end-select\"></select>\n    </div>\n    <div class=\"col2\">\n      <input class=\"hours-input\" type=\"number\" min=\"0\" max=\"10000\" oninput=\"validity.valid||(value='')\" value=\"${config ? Math.floor(config.time / 60) : 1}\"></input><span>h</span>\n      <input class=\"minutes-input\" type=\"number\" min=\"0\" max=\"10000\" oninput=\"validity.valid||(value='')\" value=\"${config ? config.time - Math.floor(config.time / 60) * 60 : 30}\"></input><span>min</span>\n    </div>\n    <div class=\"col3\">\n        <button id=\"save-btn\" class=\"mod-primary mod-bottom\">Save</button>\n        <button id=\"cancel-btn\" class=\"mod-bottom\">Cancel</button>\n    </div>`;\n    return domString;\n};\nconst getAddRowString = (withRowDiv = true) => `${withRowDiv ? '<div class=\"row clickable\">' : ''}\n  <div class=\"add-row\">\n  Add SLA\n  </div>\n  ${withRowDiv ? '</div>' : ''}`;\nconst renderAddRow = (withRowDiv = true) => stringToNode(getAddRowString(withRowDiv));\nconst renderNotEnoughListsMessage = () => stringToNode(`<div class=\"center\"><p>This Power-Up requires you to have at least two lists! </p></div>`);\nfunction onSave(e) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const rowDiv = this.parentElement.parentElement;\n        const index = [...rowDiv.parentElement.children].indexOf(rowDiv);\n        const start = rowDiv.querySelector(START_SELECT).selectedOptions[0].value;\n        const end = rowDiv.querySelector(END_SELECT).selectedOptions[0].value;\n        const hours = rowDiv.querySelector(HOURS_INPUT).value || 0;\n        const minutes = rowDiv.querySelector(MINUTES_INPUT).value || 0;\n        const name = rowDiv.querySelector(NAME_INPUT).value || '';\n        const time = parseInt(hours, 10) * 60 + parseInt(minutes, 10);\n        const configs = (yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getConfigurations\"])(t)) || [];\n        let newRow = false;\n        if (index > configs.length - 1) {\n            newRow = true;\n        }\n        if (newRow) {\n            const row = {\n                id: Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"generateUuid\"])(),\n                startCondition: {\n                    type: _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"Condition\"].ColumnName,\n                    id: start\n                },\n                endCondition: {\n                    type: _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"Condition\"].ColumnName,\n                    id: end,\n                },\n                time,\n                name,\n            };\n            configs.push(row);\n        }\n        else {\n            configs[index].startCondition.id = start;\n            configs[index].endCondition.id = end;\n            configs[index].time = time;\n            configs[index].name = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"truncate\"])(name, 50, false);\n        }\n        yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"setConfigurations\"])(t, configs);\n    });\n}\nfunction onCancel(e) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const rowDiv = this.parentElement.parentElement;\n        const index = [...rowDiv.parentElement.children].indexOf(rowDiv);\n        const configs = (yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getConfigurations\"])(t)) || [];\n        rowDiv.classList.remove('editing');\n        if (index > configs.length - 1) {\n            rowDiv.innerHTML = getAddRowString(false);\n        }\n        else {\n            rowDiv.innerHTML = getConfigString(configs[index], false);\n        }\n        // Unfreeze all rows and delete btns\n        const allRows = rowDiv.parentElement.children;\n        [].forEach.call(allRows, function (row) {\n            row.classList.add('clickable');\n        });\n        const allDeleteBtns = document.querySelectorAll('#delete-btn');\n        [].forEach.call(allDeleteBtns, function (btn) {\n            btn.disabled = false;\n        });\n    });\n}\nfunction onDelete() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const rowDiv = this.parentElement.parentElement;\n        const index = [...rowDiv.parentElement.children].indexOf(rowDiv);\n        const configs = (yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getConfigurations\"])(t)) || [];\n        configs.splice(index, 1);\n        yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"setConfigurations\"])(t, configs);\n    });\n}\nfunction onSelectOptionChange(isStart) {\n    return function fn() {\n        const rowDiv = this.parentElement.parentElement;\n        const select = isStart ? rowDiv.querySelector(END_SELECT) : rowDiv.querySelector(START_SELECT);\n        const options = createOptions(select.selectedOptions[0].value, this.selectedOptions[0].value);\n        select.innerHTML = undefined;\n        options.forEach(option => {\n            select.appendChild(option);\n        });\n    };\n}\nfunction onRowClick() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!this.classList.contains('clickable')) {\n            return;\n        }\n        // Freeze all other rows and delete btns\n        this.classList.add('editing');\n        const allRows = this.parentElement.children;\n        [].forEach.call(allRows, function (row) {\n            row.classList.remove('clickable');\n        });\n        const allDeleteBtns = document.querySelectorAll('#delete-btn');\n        [].forEach.call(allDeleteBtns, function (btn) {\n            btn.disabled = true;\n        });\n        const index = [...this.parentElement.children].indexOf(this);\n        const configs = (yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getConfigurations\"])(t)) || [];\n        let newRow = false;\n        if (index > configs.length - 1) {\n            newRow = true;\n        }\n        const config = newRow ? undefined : configs[index];\n        this.innerHTML = getConfigEditMode(config);\n        const startOptions = newRow ? createOptionsForNewRow(true) : createOptions(config.startCondition.id, config.endCondition.id);\n        const endOptions = newRow ? createOptionsForNewRow(false) : createOptions(config.endCondition.id, config.startCondition.id);\n        const startSelect = this.querySelector(START_SELECT);\n        const endSelect = this.querySelector(END_SELECT);\n        // If change option, need to make sure that the option is not present in the other select\n        startSelect.addEventListener(\"change\", onSelectOptionChange(true));\n        endSelect.addEventListener(\"change\", onSelectOptionChange(false));\n        this.querySelector('#save-btn').onclick = onSave;\n        this.querySelector('#cancel-btn').onclick = onCancel;\n        startOptions.forEach(option => {\n            startSelect.appendChild(option);\n        });\n        endOptions.forEach(option => {\n            endSelect.appendChild(option);\n        });\n    });\n}\nfunction onAuthenticate() {\n    return Trello.authorize({\n        type: \"popup\",\n        name: \"SLAs for Trello\",\n        expiration: \"never\",\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        return_url: \"https://emgoto.github.io/trello-sla/\",\n        success: () => {\n            Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"setToken\"])(t, Trello.token());\n        },\n        error: () => { },\n    });\n}\n;\nconst renderAuthenticateButton = () => stringToNode(`<div class=\"center\"><p>To view and configure SLAs, you will need to first authenticate with SLAs for Trello.</p><button id=\"authenticate-btn\" class=\"mod-bottom\">Authenticate</button><p></p></div>`);\nt.render(function () {\n    return __awaiter(this, void 0, void 0, function* () {\n        const container = document.getElementById('container');\n        container.innerHTML = '';\n        const token = yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getToken\"])(t);\n        if (!token) {\n            container.appendChild(renderAuthenticateButton());\n            document.getElementById('authenticate-btn').onclick = onAuthenticate;\n            t.sizeTo(document.getElementById('wrapper'));\n            return;\n        }\n        lists = yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getLists\"])(t);\n        if (lists.length < 2) {\n            container.appendChild(renderNotEnoughListsMessage());\n            t.sizeTo(document.getElementById('wrapper'));\n            return;\n        }\n        const configs = (yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getConfigurations\"])(t)) || [];\n        configs.forEach((config) => {\n            container.appendChild(renderConfig(config));\n        });\n        container.appendChild(renderAddRow());\n        const rows = document.querySelectorAll('.row');\n        Array.from(rows).forEach(row => row.onclick = onRowClick);\n        const deleteButtons = document.querySelectorAll('#delete-btn');\n        Array.from(deleteButtons).forEach(btn => btn.onclick = onDelete);\n        t.sizeTo(document.getElementById('wrapper'));\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2V0dGluZ3MudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NldHRpbmdzLnRzP2MxNWYiXSwic291cmNlc0NvbnRlbnQiOlsiZGVjbGFyZSBjb25zdCBUcmVsbG9Qb3dlclVwOiBhbnk7XG5jb25zdCB0ID0gVHJlbGxvUG93ZXJVcC5pZnJhbWUoKTtcbmRlY2xhcmUgY29uc3QgVHJlbGxvOiBhbnk7XG5cbmltcG9ydCB7IGdldENvbmZpZ3VyYXRpb25zLCBzZXRDb25maWd1cmF0aW9ucywgU2xhQ29uZmlndXJhdGlvbiwgQ29uZGl0aW9uLCBnZXRMaXN0cywgZ2V0VG9rZW4sIHNldFRva2VuIH0gZnJvbSAnLi90cmVsbG8tdXRpbCc7XG5pbXBvcnQgeyBnZXRIdW1hblJlYWRhYmxlVGltZSwgZ2VuZXJhdGVVdWlkLCB0cnVuY2F0ZSB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBsaXN0cyA9IFtdO1xuXG5jb25zdCBTVEFSVF9TRUxFQ1QgPSAnLnN0YXJ0LXNlbGVjdCc7XG5jb25zdCBFTkRfU0VMRUNUID0gJy5lbmQtc2VsZWN0JztcbmNvbnN0IEhPVVJTX0lOUFVUID0gJy5ob3Vycy1pbnB1dCc7XG5jb25zdCBNSU5VVEVTX0lOUFVUID0gJy5taW51dGVzLWlucHV0JztcbmNvbnN0IE5BTUVfSU5QVVQgPSAnLm5hbWUtaW5wdXQnO1xuXG5jb25zdCBzdHJpbmdUb05vZGUgPSAoZG9tU3RyaW5nOiBzdHJpbmcpOiBOb2RlID0+IHtcbiAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5pbm5lckhUTUwgPSBkb21TdHJpbmc7XG4gICAgcmV0dXJuIHdyYXBwZXIuZmlyc3RDaGlsZDtcbn07XG5cbmNvbnN0IGNvbHVtbklkVG9OYW1lID0gKGlkOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSBsaXN0cy5maW5kKGxpc3QgPT4gbGlzdC5pZCA9PT0gaWQpO1xuICAgIHJldHVybiBsaXN0ID8gbGlzdC5uYW1lIDogJzxpPkxpc3Qgbm8gbG9uZ2VyIGV4aXN0czwvaT4nO1xufTtcblxuY29uc3QgY3JlYXRlT3B0aW9ucyA9IChjdXJyZW50VmFsdWU6IHN0cmluZywgZmlsdGVyZWRWYWx1ZTogc3RyaW5nKTogRWxlbWVudFtdID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gW107XG4gICAgbGlzdHMuZm9yRWFjaChsaXN0ID0+IHtcbiAgICAgICAgaWYgKGxpc3QuaWQgIT09IGZpbHRlcmVkVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBsaXN0LmlkKTtcbiAgICAgICAgICAgIG9wdGlvbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaXN0Lm5hbWUpKTtcblxuICAgICAgICAgICAgaWYgKGxpc3QuaWQgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuXG5jb25zdCBjcmVhdGVPcHRpb25zRm9yTmV3Um93ID0gKGlzU3RhcnQ6IGJvb2xlYW4pOiBFbGVtZW50W10gPT5cbiAgICBpc1N0YXJ0ID8gY3JlYXRlT3B0aW9ucyhsaXN0c1swXS5pZCwgbGlzdHNbMV0uaWQpIDogY3JlYXRlT3B0aW9ucyhsaXN0c1sxXS5pZCwgbGlzdHNbMF0uaWQpO1xuXG5cbmNvbnN0IGdldENvbmZpZ1N0cmluZyA9IChjb25maWc6IFNsYUNvbmZpZ3VyYXRpb24sIHdpdGhSb3dEaXYgPSB0cnVlKTogc3RyaW5nID0+IFxuICAgIGAke3dpdGhSb3dEaXYgPyAnPGRpdiBjbGFzcz1cInJvdyBjbGlja2FibGVcIj4nIDogJyd9XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sMFwiPiR7dHJ1bmNhdGUoY29uZmlnLm5hbWUsIDQwLCB0cnVlKX08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb2wxXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiY29uZGl0aW9uLXR5cGVcIj5TdGFydCB3aGVuIGNhcmQgaXMgaW4gbGlzdDwvc3Bhbj5cbiAgICAgICAgPGJyPiR7dHJ1bmNhdGUoY29sdW1uSWRUb05hbWUoY29uZmlnLnN0YXJ0Q29uZGl0aW9uLmlkKSwgMjAsIHRydWUpfVxuICAgICAgICA8YnI+PHNwYW4gY2xhc3M9XCJjb25kaXRpb24tdHlwZVwiPkVuZHMgd2hlbiBjYXJkIGlzIGluIGxpc3Q8L3NwYW4+XG4gICAgICAgIDxicj4ke2NvbHVtbklkVG9OYW1lKGNvbmZpZy5lbmRDb25kaXRpb24uaWQpfVxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sMlwiPkR1cmF0aW9uOiAke2dldEh1bWFuUmVhZGFibGVUaW1lKGNvbmZpZy50aW1lKX08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb2wzXCI+PGJ1dHRvbiBpZD1cImRlbGV0ZS1idG5cIiBjbGFzcz1cIm1vZC1ib3R0b21cIj5EZWxldGU8L2J1dHRvbj48L2Rpdj5cbiAgJHt3aXRoUm93RGl2ID8gJzwvZGl2PicgOiAnJ31gO1xuICBcbmNvbnN0IHJlbmRlckNvbmZpZyA9IChjb25maWc6IFNsYUNvbmZpZ3VyYXRpb24sIHdpdGhSb3dEaXYgPSB0cnVlKTogTm9kZSA9PiBcbiAgICBzdHJpbmdUb05vZGUoZ2V0Q29uZmlnU3RyaW5nKGNvbmZpZywgd2l0aFJvd0RpdikpO1xuXG5jb25zdCBnZXRDb25maWdFZGl0TW9kZSA9IChjb25maWc/OiBTbGFDb25maWd1cmF0aW9uKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBkb21TdHJpbmcgPSBgXG4gICAgPGRpdiBjbGFzcz1cImNvbDBcIj5cbiAgICAgIDxpbnB1dCBjbGFzcz1cIm5hbWUtaW5wdXRcIiB2YWx1ZT0ke2NvbmZpZyA/IGBcIiR7Y29uZmlnLm5hbWV9XCJgIDogXCJTTEEgTmFtZVwifT48L2lucHV0PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2wxXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cImNvbmRpdGlvbi10eXBlXCI+U3RhcnQgd2hlbiBjYXJkIGlzIGluIGxpc3Q8L3NwYW4+XG4gICAgICA8YnI+PHNlbGVjdCBjbGFzcz1cInN0YXJ0LXNlbGVjdFwiPjwvc2VsZWN0PlxuICAgICAgPGJyPjxzcGFuIGNsYXNzPVwiY29uZGl0aW9uLXR5cGVcIj5FbmQgd2hlbiBjYXJkIGlzIGluIGxpc3Q8L3NwYW4+XG4gICAgICA8YnI+PHNlbGVjdCBjbGFzcz1cImVuZC1zZWxlY3RcIj48L3NlbGVjdD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sMlwiPlxuICAgICAgPGlucHV0IGNsYXNzPVwiaG91cnMtaW5wdXRcIiB0eXBlPVwibnVtYmVyXCIgbWluPVwiMFwiIG1heD1cIjEwMDAwXCIgb25pbnB1dD1cInZhbGlkaXR5LnZhbGlkfHwodmFsdWU9JycpXCIgdmFsdWU9XCIke2NvbmZpZyA/IE1hdGguZmxvb3IoY29uZmlnLnRpbWUgLyA2MCkgOiAxfVwiPjwvaW5wdXQ+PHNwYW4+aDwvc3Bhbj5cbiAgICAgIDxpbnB1dCBjbGFzcz1cIm1pbnV0ZXMtaW5wdXRcIiB0eXBlPVwibnVtYmVyXCIgbWluPVwiMFwiIG1heD1cIjEwMDAwXCIgb25pbnB1dD1cInZhbGlkaXR5LnZhbGlkfHwodmFsdWU9JycpXCIgdmFsdWU9XCIke2NvbmZpZyA/IGNvbmZpZy50aW1lIC0gTWF0aC5mbG9vcihjb25maWcudGltZSAvIDYwKSAqIDYwIDogMzB9XCI+PC9pbnB1dD48c3Bhbj5taW48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbDNcIj5cbiAgICAgICAgPGJ1dHRvbiBpZD1cInNhdmUtYnRuXCIgY2xhc3M9XCJtb2QtcHJpbWFyeSBtb2QtYm90dG9tXCI+U2F2ZTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGlkPVwiY2FuY2VsLWJ0blwiIGNsYXNzPVwibW9kLWJvdHRvbVwiPkNhbmNlbDwvYnV0dG9uPlxuICAgIDwvZGl2PmA7XG5cbiAgICByZXR1cm4gZG9tU3RyaW5nO1xufTtcblxuY29uc3QgZ2V0QWRkUm93U3RyaW5nID0gKHdpdGhSb3dEaXYgPSB0cnVlKTogc3RyaW5nID0+XG4gICAgYCR7d2l0aFJvd0RpdiA/ICc8ZGl2IGNsYXNzPVwicm93IGNsaWNrYWJsZVwiPicgOiAnJ31cbiAgPGRpdiBjbGFzcz1cImFkZC1yb3dcIj5cbiAgQWRkIFNMQVxuICA8L2Rpdj5cbiAgJHt3aXRoUm93RGl2ID8gJzwvZGl2PicgOiAnJ31gO1xuXG5jb25zdCByZW5kZXJBZGRSb3cgPSAod2l0aFJvd0RpdiA9IHRydWUpOiBOb2RlID0+IFxuICAgIHN0cmluZ1RvTm9kZShnZXRBZGRSb3dTdHJpbmcod2l0aFJvd0RpdikpO1xuXG5cbmNvbnN0IHJlbmRlck5vdEVub3VnaExpc3RzTWVzc2FnZSA9ICgpOiBOb2RlID0+XG4gICAgc3RyaW5nVG9Ob2RlKGA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+PHA+VGhpcyBQb3dlci1VcCByZXF1aXJlcyB5b3UgdG8gaGF2ZSBhdCBsZWFzdCB0d28gbGlzdHMhIDwvcD48L2Rpdj5gKTtcblxuYXN5bmMgZnVuY3Rpb24gb25TYXZlKGU6IEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgcm93RGl2ID0gdGhpcy5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgaW5kZXggPSBbLi4ucm93RGl2LnBhcmVudEVsZW1lbnQuY2hpbGRyZW5dLmluZGV4T2Yocm93RGl2KTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gcm93RGl2LnF1ZXJ5U2VsZWN0b3IoU1RBUlRfU0VMRUNUKS5zZWxlY3RlZE9wdGlvbnNbMF0udmFsdWU7XG4gICAgY29uc3QgZW5kID0gcm93RGl2LnF1ZXJ5U2VsZWN0b3IoRU5EX1NFTEVDVCkuc2VsZWN0ZWRPcHRpb25zWzBdLnZhbHVlO1xuICAgIGNvbnN0IGhvdXJzID0gcm93RGl2LnF1ZXJ5U2VsZWN0b3IoSE9VUlNfSU5QVVQpLnZhbHVlIHx8IDA7XG4gICAgY29uc3QgbWludXRlcyA9IHJvd0Rpdi5xdWVyeVNlbGVjdG9yKE1JTlVURVNfSU5QVVQpLnZhbHVlIHx8IDA7XG4gICAgY29uc3QgbmFtZSA9IHJvd0Rpdi5xdWVyeVNlbGVjdG9yKE5BTUVfSU5QVVQpLnZhbHVlIHx8ICcnO1xuXG4gICAgY29uc3QgdGltZSA9IHBhcnNlSW50KGhvdXJzLCAxMCkgKiA2MCArIHBhcnNlSW50KG1pbnV0ZXMsIDEwKTtcblxuICAgIGNvbnN0IGNvbmZpZ3MgPSBhd2FpdCBnZXRDb25maWd1cmF0aW9ucyh0KSB8fCBbXTtcblxuICAgIGxldCBuZXdSb3cgPSBmYWxzZTtcbiAgICBpZiAoIGluZGV4ID4gY29uZmlncy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5ld1JvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5ld1Jvdykge1xuICAgICAgICBjb25zdCByb3cgPSB7XG4gICAgICAgICAgICBpZDogZ2VuZXJhdGVVdWlkKCksXG4gICAgICAgICAgICBzdGFydENvbmRpdGlvbjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IENvbmRpdGlvbi5Db2x1bW5OYW1lLFxuICAgICAgICAgICAgICAgIGlkOiBzdGFydFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZENvbmRpdGlvbjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IENvbmRpdGlvbi5Db2x1bW5OYW1lLFxuICAgICAgICAgICAgICAgIGlkOiBlbmQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbmZpZ3MucHVzaChyb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZ3NbaW5kZXhdLnN0YXJ0Q29uZGl0aW9uLmlkID0gc3RhcnQ7XG4gICAgICAgIGNvbmZpZ3NbaW5kZXhdLmVuZENvbmRpdGlvbi5pZCA9IGVuZDtcbiAgICAgICAgY29uZmlnc1tpbmRleF0udGltZSA9IHRpbWU7XG4gICAgICAgIGNvbmZpZ3NbaW5kZXhdLm5hbWUgPSB0cnVuY2F0ZShuYW1lLCA1MCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGF3YWl0IHNldENvbmZpZ3VyYXRpb25zKHQsIGNvbmZpZ3MpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBvbkNhbmNlbChlOiBFdmVudCkge1xuICAgIGNvbnN0IHJvd0RpdiA9IHRoaXMucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGNvbnN0IGluZGV4ID0gWy4uLnJvd0Rpdi5wYXJlbnRFbGVtZW50LmNoaWxkcmVuXS5pbmRleE9mKHJvd0Rpdik7XG4gICAgY29uc3QgY29uZmlncyA9IGF3YWl0IGdldENvbmZpZ3VyYXRpb25zKHQpIHx8IFtdO1xuXG4gICAgcm93RGl2LmNsYXNzTGlzdC5yZW1vdmUoJ2VkaXRpbmcnKTtcblxuICAgIGlmICggaW5kZXggPiBjb25maWdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcm93RGl2LmlubmVySFRNTCA9IGdldEFkZFJvd1N0cmluZyhmYWxzZSk7XG4gICAgXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm93RGl2LmlubmVySFRNTCA9IGdldENvbmZpZ1N0cmluZyhjb25maWdzW2luZGV4XSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIFVuZnJlZXplIGFsbCByb3dzIGFuZCBkZWxldGUgYnRuc1xuICAgIGNvbnN0IGFsbFJvd3MgPSByb3dEaXYucGFyZW50RWxlbWVudC5jaGlsZHJlbjtcbiAgICBbXS5mb3JFYWNoLmNhbGwoYWxsUm93cywgZnVuY3Rpb24ocm93KSB7IFxuICAgICAgICByb3cuY2xhc3NMaXN0LmFkZCgnY2xpY2thYmxlJyk7XG4gICAgfSk7XG4gICAgY29uc3QgYWxsRGVsZXRlQnRucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkZWxldGUtYnRuJyk7XG4gICAgW10uZm9yRWFjaC5jYWxsKGFsbERlbGV0ZUJ0bnMsIGZ1bmN0aW9uKGJ0bikge1xuICAgICAgICBidG4uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25EZWxldGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgcm93RGl2ID0gdGhpcy5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgaW5kZXggPSBbLi4ucm93RGl2LnBhcmVudEVsZW1lbnQuY2hpbGRyZW5dLmluZGV4T2Yocm93RGl2KTtcbiAgICBjb25zdCBjb25maWdzID0gYXdhaXQgZ2V0Q29uZmlndXJhdGlvbnModCkgfHwgW107XG5cbiAgICBjb25maWdzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBhd2FpdCBzZXRDb25maWd1cmF0aW9ucyh0LCBjb25maWdzKTtcbn1cblxuZnVuY3Rpb24gb25TZWxlY3RPcHRpb25DaGFuZ2UoaXNTdGFydDogYm9vbGVhbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBmbigpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgcm93RGl2ID0gdGhpcy5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHNlbGVjdCA9IGlzU3RhcnQgPyByb3dEaXYucXVlcnlTZWxlY3RvcihFTkRfU0VMRUNUKSA6IHJvd0Rpdi5xdWVyeVNlbGVjdG9yKFNUQVJUX1NFTEVDVCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjcmVhdGVPcHRpb25zKHNlbGVjdC5zZWxlY3RlZE9wdGlvbnNbMF0udmFsdWUsIHRoaXMuc2VsZWN0ZWRPcHRpb25zWzBdLnZhbHVlKTtcbiAgICAgICAgc2VsZWN0LmlubmVySFRNTCA9IHVuZGVmaW5lZDtcbiAgICAgICAgb3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25Sb3dDbGljaygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdjbGlja2FibGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRnJlZXplIGFsbCBvdGhlciByb3dzIGFuZCBkZWxldGUgYnRuc1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZWRpdGluZycpO1xuICAgIGNvbnN0IGFsbFJvd3MgPSB0aGlzLnBhcmVudEVsZW1lbnQuY2hpbGRyZW47XG4gICAgW10uZm9yRWFjaC5jYWxsKGFsbFJvd3MsIGZ1bmN0aW9uKHJvdykgeyBcbiAgICAgICAgcm93LmNsYXNzTGlzdC5yZW1vdmUoJ2NsaWNrYWJsZScpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFsbERlbGV0ZUJ0bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZGVsZXRlLWJ0bicpO1xuICAgIFtdLmZvckVhY2guY2FsbChhbGxEZWxldGVCdG5zLCBmdW5jdGlvbihidG4pIHtcbiAgICAgICAgYnRuLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGluZGV4ID0gWy4uLnRoaXMucGFyZW50RWxlbWVudC5jaGlsZHJlbl0uaW5kZXhPZih0aGlzKTtcbiAgICBjb25zdCBjb25maWdzOiBTbGFDb25maWd1cmF0aW9uW10gPSBhd2FpdCBnZXRDb25maWd1cmF0aW9ucyh0KSB8fCBbXTtcblxuICAgIGxldCBuZXdSb3cgPSBmYWxzZTtcbiAgICBpZiAoIGluZGV4ID4gY29uZmlncy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5ld1JvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlnID0gbmV3Um93ID8gdW5kZWZpbmVkIDogY29uZmlnc1tpbmRleF07XG5cbiAgICB0aGlzLmlubmVySFRNTCA9IGdldENvbmZpZ0VkaXRNb2RlKGNvbmZpZyk7XG5cbiAgICBjb25zdCBzdGFydE9wdGlvbnMgPSBuZXdSb3cgPyBjcmVhdGVPcHRpb25zRm9yTmV3Um93KHRydWUpIDogY3JlYXRlT3B0aW9ucyhjb25maWcuc3RhcnRDb25kaXRpb24uaWQsIGNvbmZpZy5lbmRDb25kaXRpb24uaWQpO1xuICAgIGNvbnN0IGVuZE9wdGlvbnMgPSBuZXdSb3cgPyBjcmVhdGVPcHRpb25zRm9yTmV3Um93KGZhbHNlKSA6IGNyZWF0ZU9wdGlvbnMoY29uZmlnLmVuZENvbmRpdGlvbi5pZCwgY29uZmlnLnN0YXJ0Q29uZGl0aW9uLmlkKTtcblxuICAgIGNvbnN0IHN0YXJ0U2VsZWN0ID0gdGhpcy5xdWVyeVNlbGVjdG9yKFNUQVJUX1NFTEVDVCk7XG4gICAgY29uc3QgZW5kU2VsZWN0ID0gdGhpcy5xdWVyeVNlbGVjdG9yKEVORF9TRUxFQ1QpO1xuXG4gICAgLy8gSWYgY2hhbmdlIG9wdGlvbiwgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgb3B0aW9uIGlzIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBzZWxlY3RcbiAgICBzdGFydFNlbGVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG9uU2VsZWN0T3B0aW9uQ2hhbmdlKHRydWUpKTtcbiAgICBlbmRTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBvblNlbGVjdE9wdGlvbkNoYW5nZShmYWxzZSkpO1xuICAgIHRoaXMucXVlcnlTZWxlY3RvcignI3NhdmUtYnRuJykub25jbGljayA9IG9uU2F2ZTtcbiAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNjYW5jZWwtYnRuJykub25jbGljayA9IG9uQ2FuY2VsO1xuXG4gICAgc3RhcnRPcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgc3RhcnRTZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICB9KTtcbiAgICBlbmRPcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgZW5kU2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQXV0aGVudGljYXRlKCkge1xuICAgIHJldHVybiBUcmVsbG8uYXV0aG9yaXplKHtcbiAgICAgICAgdHlwZTogXCJwb3B1cFwiLFxuICAgICAgICBuYW1lOiBcIlNMQXMgZm9yIFRyZWxsb1wiLFxuICAgICAgICBleHBpcmF0aW9uOiBcIm5ldmVyXCIsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlXG4gICAgICAgIHJldHVybl91cmw6XCJodHRwczovL2VtZ290by5naXRodWIuaW8vdHJlbGxvLXNsYS9cIiwgXG4gICAgICAgIHN1Y2Nlc3M6ICgpID0+IHtcbiAgICAgICAgICAgIHNldFRva2VuKHQsIFRyZWxsby50b2tlbigpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6ICgpID0+IHsgfSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IHJlbmRlckF1dGhlbnRpY2F0ZUJ1dHRvbiA9ICgpID0+IFxuICAgIHN0cmluZ1RvTm9kZShgPGRpdiBjbGFzcz1cImNlbnRlclwiPjxwPlRvIHZpZXcgYW5kIGNvbmZpZ3VyZSBTTEFzLCB5b3Ugd2lsbCBuZWVkIHRvIGZpcnN0IGF1dGhlbnRpY2F0ZSB3aXRoIFNMQXMgZm9yIFRyZWxsby48L3A+PGJ1dHRvbiBpZD1cImF1dGhlbnRpY2F0ZS1idG5cIiBjbGFzcz1cIm1vZC1ib3R0b21cIj5BdXRoZW50aWNhdGU8L2J1dHRvbj48cD48L3A+PC9kaXY+YCk7XG5cbnQucmVuZGVyKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0VG9rZW4odCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocmVuZGVyQXV0aGVudGljYXRlQnV0dG9uKCkpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXV0aGVudGljYXRlLWJ0bicpLm9uY2xpY2sgPSBvbkF1dGhlbnRpY2F0ZTtcbiAgICAgICAgdC5zaXplVG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZXInKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsaXN0cyA9IGF3YWl0IGdldExpc3RzKHQpO1xuXG4gICAgaWYgKGxpc3RzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJlbmRlck5vdEVub3VnaExpc3RzTWVzc2FnZSgpKTtcbiAgICAgICAgdC5zaXplVG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZXInKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWdzID0gYXdhaXQgZ2V0Q29uZmlndXJhdGlvbnModCkgfHwgW107XG5cbiAgICBjb25maWdzLmZvckVhY2goKGNvbmZpZykgPT4ge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocmVuZGVyQ29uZmlnKGNvbmZpZykpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJlbmRlckFkZFJvdygpKTtcblxuICAgIGNvbnN0IHJvd3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucm93JykgYXMgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD47XG4gICAgQXJyYXkuZnJvbShyb3dzKS5mb3JFYWNoKHJvdyA9PiByb3cub25jbGljayA9IG9uUm93Q2xpY2spO1xuXG4gICAgY29uc3QgZGVsZXRlQnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkZWxldGUtYnRuJykgYXMgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD47XG4gICAgQXJyYXkuZnJvbShkZWxldGVCdXR0b25zKS5mb3JFYWNoKGJ0biA9PiBidG4ub25jbGljayA9IG9uRGVsZXRlKTtcbiAgXG4gICAgdC5zaXplVG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyYXBwZXInKSk7XG59KTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUVBO0FBR0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFFQTs7OztBQUtBO0FBRUE7QUFJQTtBQUdBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/settings.ts\n");

/***/ }),

/***/ "./src/trello-util.ts":
/*!****************************!*\
  !*** ./src/trello-util.ts ***!
  \****************************/
/*! exports provided: Condition, CardActionType, getConfigurations, setConfigurations, getSlaData, setSlaData, getToken, setToken, getBoardActions, getCardActions, getLists */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Condition\", function() { return Condition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CardActionType\", function() { return CardActionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getConfigurations\", function() { return getConfigurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setConfigurations\", function() { return setConfigurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSlaData\", function() { return getSlaData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setSlaData\", function() { return setSlaData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getToken\", function() { return getToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setToken\", function() { return setToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBoardActions\", function() { return getBoardActions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCardActions\", function() { return getCardActions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLists\", function() { return getLists; });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst key = '652d72f229f65b3457533bd55fdcf436';\n// Right now we only provide being in a column as starting the SLA\nvar Condition;\n(function (Condition) {\n    Condition[\"ColumnName\"] = \"COLUMN_NAME\";\n})(Condition || (Condition = {}));\nvar CardActionType;\n(function (CardActionType) {\n    CardActionType[\"createCard\"] = \"createCard\";\n    CardActionType[\"updateCard\"] = \"updateCard\";\n})(CardActionType || (CardActionType = {}));\nconst getConfigurations = (t) => t.get('board', 'shared', 'config');\nconst setConfigurations = (t, config) => t.set('board', 'shared', 'config', config);\nconst getSlaData = (t) => t.get('card', 'shared', 'slaData');\nconst setSlaData = (t, slaData) => t.set('card', 'shared', 'slaData', slaData);\nconst getToken = (t) => t.get('member', 'private', 'authToken');\nconst setToken = (t, token) => t.set('member', 'private', 'authToken', token);\n/**\n * TODO: the problem with getting all board actions is that there is a limit of 1000\n * And that the actions for closed cards are also counted.\n */\nconst getBoardActions = (t) => __awaiter(void 0, void 0, void 0, function* () {\n    const { board: boardId } = t.getContext();\n    const token = yield getToken(t);\n    const url = `https://api.trello.com/1/boards/${boardId}/actions?limit=1000&filter=updateCard:idList,createCard&member=false&memberCreator=false&key=${key}&token=${token}`;\n    return axios.get(url)\n        .then(response => {\n        return response.data;\n    })\n        .catch((e) => {\n        if (e && e.response && e.response.status && e.response.status === 401) {\n            setToken(t, undefined);\n        }\n    });\n});\nconst getCardActions = (t) => __awaiter(void 0, void 0, void 0, function* () {\n    const { card: cardId } = t.getContext();\n    const token = yield getToken(t);\n    const url = `https://api.trello.com/1/cards/${cardId}/actions?filter=updateCard:idList,createCard&key=${key}&token=${token}`;\n    return axios.get(url).then(response => response.data).catch((e) => {\n        if (e && e.response && e.response.status && e.response.status === 401) {\n            setToken(t, undefined);\n        }\n    });\n});\n// TODO: don't need to call API for this when there is t.lists()\nconst getLists = (t) => __awaiter(void 0, void 0, void 0, function* () {\n    const { board: boardId } = t.getContext();\n    const token = yield getToken(t);\n    const url = `https://api.trello.com/1/boards/${boardId}/lists?cards=none&filter=open&key=${key}&token=${token}`;\n    return axios.get(url).then(response => response.data).catch((e) => {\n        if (e && e.response && e.response.status && e.response.status === 401) {\n            setToken(t, undefined);\n        }\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHJlbGxvLXV0aWwudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RyZWxsby11dGlsLnRzP2JhYjciXSwic291cmNlc0NvbnRlbnQiOlsiZGVjbGFyZSBjb25zdCBheGlvczogYW55O1xuXG5jb25zdCBrZXkgPSAnNjUyZDcyZjIyOWY2NWIzNDU3NTMzYmQ1NWZkY2Y0MzYnO1xuXG4vLyBSaWdodCBub3cgd2Ugb25seSBwcm92aWRlIGJlaW5nIGluIGEgY29sdW1uIGFzIHN0YXJ0aW5nIHRoZSBTTEFcbmV4cG9ydCBlbnVtIENvbmRpdGlvbiB7XG4gICAgQ29sdW1uTmFtZSA9IFwiQ09MVU1OX05BTUVcIixcbn1cblxuZXhwb3J0IGVudW0gQ2FyZEFjdGlvblR5cGUgeyBcbiAgICBjcmVhdGVDYXJkID0gXCJjcmVhdGVDYXJkXCIsXG4gICAgdXBkYXRlQ2FyZCA9IFwidXBkYXRlQ2FyZFwiXG59XG5cbmV4cG9ydCB0eXBlIFNsYUNvbmRpdGlvbiA9IHtcbiAgICB0eXBlOiBDb25kaXRpb247XG4gICAgaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgU2xhQ29uZmlndXJhdGlvbiA9IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzdGFydENvbmRpdGlvbjogU2xhQ29uZGl0aW9uO1xuICAgIGVuZENvbmRpdGlvbjogU2xhQ29uZGl0aW9uO1xuICAgIHRpbWU6IG51bWJlcjsgLy8gTWludXRlc1xufVxuXG5leHBvcnQgdHlwZSBTbGFEYXRhID0ge1xuICAgIHN0YXJ0VGltZT86IG51bWJlcjsgLy8gVW5peCB0aW1lc3RhbXAgbWlsbGlzZWNvbmRzLiBPbmx5IGV4aXN0cyBpZiBTTEEgaGFzIHN0YXJ0ZWRcbiAgICBlbmRUaW1lPzogbnVtYmVyOyAvLyBVbml4IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHMuIE9ubHkgZXhpc3RzIGlmIFNMQSBoYXMgZW5kZWRcbn1cblxuZXhwb3J0IHR5cGUgU2xhRGF0YU1hcCA9IHtcbiAgICBbaWQ6IG51bWJlcl06IFNsYURhdGE7XG59XG5cbmV4cG9ydCB0eXBlIENhcmRBY3Rpb24gPSBDcmVhdGVDYXJkQWN0aW9uIHwgVXBkYXRlQ2FyZEFjdGlvbjtcblxuZXhwb3J0IHR5cGUgVXBkYXRlQ2FyZEFjdGlvbiA9IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGRhdGE6IHtcbiAgICAgICAgbGlzdEFmdGVyOiB7aWQ6IHN0cmluZ307XG4gICAgICAgIGxpc3RCZWZvcmU6IHtpZDogc3RyaW5nfTtcbiAgICB9O1xuICAgIHR5cGU6IHR5cGVvZiBDYXJkQWN0aW9uVHlwZS51cGRhdGVDYXJkO1xuICAgIGRhdGU6IHN0cmluZzsgLy8gZm9ybWF0IDIwMTktMTEtMjlUMjE6MDU6MjguNTEwWlxufVxuXG5leHBvcnQgdHlwZSBDcmVhdGVDYXJkQWN0aW9uID0ge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgZGF0YToge1xuICAgICAgICBsaXN0OiB7aWQ6IHN0cmluZ307XG4gICAgfTtcbiAgICB0eXBlOiB0eXBlb2YgQ2FyZEFjdGlvblR5cGUuY3JlYXRlQ2FyZDtcbiAgICBkYXRlOiBzdHJpbmc7IC8vIGZvcm1hdCAyMDE5LTExLTI5VDIxOjA1OjI4LjUxMFpcbn1cblxudHlwZSBOYW1lQW5kSWQgPSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIExpc3QgPSBOYW1lQW5kSWQ7XG5cbmV4cG9ydCB0eXBlIEJvYXJkQWN0aW9uID0ge1xuICAgIGRhdGE6IHtcbiAgICAgICAgYm9hcmQ6IE5hbWVBbmRJZDtcbiAgICAgICAgY2FyZDogTmFtZUFuZElkO1xuICAgICAgICBsaXN0PzogTmFtZUFuZElkO1xuICAgICAgICBsaXN0QmVmb3JlPzogTmFtZUFuZElkO1xuICAgICAgICBsaXN0QWZ0ZXI/OiBOYW1lQW5kSWQ7XG4gICAgfTtcbiAgICBkYXRlOiBzdHJpbmc7XG4gICAgdHlwZTogQ2FyZEFjdGlvblR5cGU7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb25maWd1cmF0aW9ucyA9ICh0KTogUHJvbWlzZTxTbGFDb25maWd1cmF0aW9uW10gfCB2b2lkPiA9PiB0LmdldCgnYm9hcmQnLCAnc2hhcmVkJywgJ2NvbmZpZycpO1xuZXhwb3J0IGNvbnN0IHNldENvbmZpZ3VyYXRpb25zID0gKHQsIGNvbmZpZzogU2xhQ29uZmlndXJhdGlvbltdKTogdm9pZCA9PiB0LnNldCgnYm9hcmQnLCAnc2hhcmVkJywgJ2NvbmZpZycsIGNvbmZpZyk7XG5leHBvcnQgY29uc3QgZ2V0U2xhRGF0YSA9ICh0KTogUHJvbWlzZTxTbGFEYXRhTWFwIHwgdm9pZD4gPT4gdC5nZXQoJ2NhcmQnLCAnc2hhcmVkJywgJ3NsYURhdGEnKTtcbmV4cG9ydCBjb25zdCBzZXRTbGFEYXRhID0gKHQsIHNsYURhdGE6IFNsYURhdGFNYXApOiB2b2lkID0+IHQuc2V0KCdjYXJkJywgJ3NoYXJlZCcsICdzbGFEYXRhJywgc2xhRGF0YSk7XG5leHBvcnQgY29uc3QgZ2V0VG9rZW4gPSAodCk6IFByb21pc2U8c3RyaW5nIHwgdm9pZD4gPT4gdC5nZXQoJ21lbWJlcicsICdwcml2YXRlJywgJ2F1dGhUb2tlbicpO1xuZXhwb3J0IGNvbnN0IHNldFRva2VuID0gKHQsIHRva2VuKTogUHJvbWlzZTx2b2lkPiA9PiB0LnNldCgnbWVtYmVyJywgJ3ByaXZhdGUnLCAnYXV0aFRva2VuJywgdG9rZW4pO1xuXG4vKipcbiAqIFRPRE86IHRoZSBwcm9ibGVtIHdpdGggZ2V0dGluZyBhbGwgYm9hcmQgYWN0aW9ucyBpcyB0aGF0IHRoZXJlIGlzIGEgbGltaXQgb2YgMTAwMFxuICogQW5kIHRoYXQgdGhlIGFjdGlvbnMgZm9yIGNsb3NlZCBjYXJkcyBhcmUgYWxzbyBjb3VudGVkLlxuICovIFxuZXhwb3J0IGNvbnN0IGdldEJvYXJkQWN0aW9ucyA9IGFzeW5jICh0KTogUHJvbWlzZTxCb2FyZEFjdGlvbltdPiA9PiB7XG4gICAgY29uc3QgeyBib2FyZDogYm9hcmRJZCB9ID0gdC5nZXRDb250ZXh0KCk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZXRUb2tlbih0KTtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9hcGkudHJlbGxvLmNvbS8xL2JvYXJkcy8ke2JvYXJkSWR9L2FjdGlvbnM/bGltaXQ9MTAwMCZmaWx0ZXI9dXBkYXRlQ2FyZDppZExpc3QsY3JlYXRlQ2FyZCZtZW1iZXI9ZmFsc2UmbWVtYmVyQ3JlYXRvcj1mYWxzZSZrZXk9JHtrZXl9JnRva2VuPSR7dG9rZW59YDtcbiAgICByZXR1cm4gYXhpb3MuZ2V0KHVybClcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5yZXNwb25zZSAmJiBlLnJlc3BvbnNlLnN0YXR1cyAmJiBlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgc2V0VG9rZW4odCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2FyZEFjdGlvbnMgPSBhc3luYyAodCk6IFByb21pc2U8Q2FyZEFjdGlvbltdPiA9PiB7XG4gICAgY29uc3QgeyBjYXJkOiBjYXJkSWQgfSA9IHQuZ2V0Q29udGV4dCgpO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0VG9rZW4odCk7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vYXBpLnRyZWxsby5jb20vMS9jYXJkcy8ke2NhcmRJZH0vYWN0aW9ucz9maWx0ZXI9dXBkYXRlQ2FyZDppZExpc3QsY3JlYXRlQ2FyZCZrZXk9JHtrZXl9JnRva2VuPSR7dG9rZW59YDtcbiAgICByZXR1cm4gYXhpb3MuZ2V0KHVybCkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5kYXRhKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLnJlc3BvbnNlICYmIGUucmVzcG9uc2Uuc3RhdHVzICYmIGUucmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIHNldFRva2VuKHQsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIFRPRE86IGRvbid0IG5lZWQgdG8gY2FsbCBBUEkgZm9yIHRoaXMgd2hlbiB0aGVyZSBpcyB0Lmxpc3RzKClcbmV4cG9ydCBjb25zdCBnZXRMaXN0cyA9IGFzeW5jICh0KTogUHJvbWlzZTxMaXN0W10+ID0+IHtcbiAgICBjb25zdCB7IGJvYXJkOiBib2FyZElkIH0gPSB0LmdldENvbnRleHQoKTtcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGdldFRva2VuKHQpO1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovL2FwaS50cmVsbG8uY29tLzEvYm9hcmRzLyR7Ym9hcmRJZH0vbGlzdHM/Y2FyZHM9bm9uZSZmaWx0ZXI9b3BlbiZrZXk9JHtrZXl9JnRva2VuPSR7dG9rZW59YDtcbiAgICByZXR1cm4gYXhpb3MuZ2V0KHVybCkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5kYXRhKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLnJlc3BvbnNlICYmIGUucmVzcG9uc2Uuc3RhdHVzICYmIGUucmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIHNldFRva2VuKHQsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/trello-util.ts\n");

/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/*! exports provided: truncate, getHumanReadableTime, getMinutesRemaining, getColor, getRunningSlas, getEndTime, getStartTime, getUpdatedSlaData, updateConfigs, getActionsPerCard, updateAllConfigs, generateUuid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"truncate\", function() { return truncate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHumanReadableTime\", function() { return getHumanReadableTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMinutesRemaining\", function() { return getMinutesRemaining; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getColor\", function() { return getColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRunningSlas\", function() { return getRunningSlas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getEndTime\", function() { return getEndTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStartTime\", function() { return getStartTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUpdatedSlaData\", function() { return getUpdatedSlaData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateConfigs\", function() { return updateConfigs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getActionsPerCard\", function() { return getActionsPerCard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateAllConfigs\", function() { return updateAllConfigs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateUuid\", function() { return generateUuid; });\n/* harmony import */ var _trello_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trello-util */ \"./src/trello-util.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nconst truncate = (str, n, shouldEllipse) => (str.length > n) ? str.substr(0, n - 1) + `${shouldEllipse ? '&hellip;' : ''}` : str;\nconst getHumanReadableTime = (realMinutes) => {\n    const isNegative = realMinutes < 0;\n    const minutes = isNegative ? realMinutes * -1 : realMinutes;\n    const negativeSign = isNegative ? '-' : '';\n    const MINUTES = 'min';\n    const HOURS = 'h';\n    const DAYS = 'd';\n    if (minutes < 60) {\n        return `${negativeSign}${minutes}${MINUTES}`;\n    }\n    if (minutes < 1440) {\n        const hours = Math.floor(minutes / 60);\n        const hoursString = hours > 0 ? `${hours}${HOURS}` : '';\n        const remainingMinutes = minutes - 60 * hours;\n        const minutesString = remainingMinutes > 0 ? `${remainingMinutes}${MINUTES}` : '';\n        const spacer = hoursString && minutesString ? ' ' : '';\n        return `${negativeSign}${hoursString}${spacer}${minutesString}`;\n    }\n    const days = Math.floor(minutes / 1440);\n    const daysString = days > 0 ? `${days}${DAYS}` : '';\n    const remainingMinutes = minutes - days * 1440;\n    const remainingHours = Math.floor(remainingMinutes / 60);\n    const hoursString = remainingHours > 0 ? `${remainingHours}${HOURS}` : '';\n    const spacer = daysString && hoursString ? ' ' : '';\n    return `${negativeSign}${daysString}${spacer}${hoursString}`;\n};\nconst getMinutesRemaining = (startTime, endTime, config) => {\n    const minutesElapsed = Math.floor((endTime - startTime) / 1000 / 60);\n    const minutesRemaining = config.time - minutesElapsed;\n    return minutesRemaining;\n};\nconst getColor = (minutesRemaining, isComplete) => {\n    if (isComplete) {\n        return 'grey';\n    }\n    ;\n    if (minutesRemaining < 0) {\n        return 'red';\n    }\n    else if (minutesRemaining < 60) {\n        return 'yellow';\n    }\n    return 'green';\n};\nconst getRunningSlas = (data, configs, detailed) => {\n    const runningSlas = [];\n    const completeSlas = [];\n    configs.forEach((config) => {\n        if (data[config.id]) {\n            const { startTime, endTime } = data[config.id];\n            if (startTime && !endTime) {\n                runningSlas.push({\n                    dynamic: function () {\n                        const unix = moment().valueOf();\n                        const minutesRemaining = getMinutesRemaining(startTime, unix, config);\n                        const humanReadable = getHumanReadableTime(minutesRemaining);\n                        return Object.assign(Object.assign(Object.assign({ text: humanReadable, color: getColor(minutesRemaining, false) }, (detailed ? { title: `${config.name} - Ongoing` } : {})), (!detailed ? { icon: `${window.location}img/stopwatch.svg` } : {})), { refresh: 60 });\n                    }\n                });\n            }\n            if (startTime && endTime && detailed) {\n                const minutesRemaining = getMinutesRemaining(startTime, endTime, config);\n                const humanReadable = getHumanReadableTime(minutesRemaining);\n                completeSlas.push({\n                    text: humanReadable,\n                    color: getColor(minutesRemaining, true),\n                    title: `${config.name} - stopped`,\n                });\n            }\n        }\n    });\n    // We want the complete SLAs to come after the running ones\n    const allSlas = runningSlas.concat(completeSlas);\n    return allSlas;\n};\nconst getEndTime = (actions, endCondition, startTime) => {\n    let endTime = undefined;\n    actions.forEach((action) => {\n        if (action.type === _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"CardActionType\"].updateCard) {\n            if (action.data.listAfter.id === endCondition.id &&\n                (!endTime || moment(action.date).valueOf() < endTime) &&\n                moment(action.date).valueOf() > startTime) {\n                endTime = moment(action.date).valueOf();\n            }\n        }\n    });\n    return endTime;\n};\nconst getStartTime = (actions, startCondition) => {\n    let startTime = undefined;\n    actions.forEach((action) => {\n        if (action.type === _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"CardActionType\"].createCard && action.data.list.id === startCondition.id) {\n            startTime = moment(action.date).valueOf();\n        }\n        else if (action.type === _trello_util__WEBPACK_IMPORTED_MODULE_0__[\"CardActionType\"].updateCard &&\n            action.data.listAfter.id === startCondition.id &&\n            !startTime || (moment(action.date).valueOf() < startTime)) {\n            startTime = moment(action.date).valueOf();\n        }\n    });\n    return startTime;\n};\nconst getUpdatedSlaData = (actions, configs, slaMap) => {\n    const updatedSlaMap = slaMap;\n    let hasChanged = false;\n    configs.forEach(config => {\n        const { id, startCondition, endCondition } = config;\n        if (!updatedSlaMap[id]) {\n            updatedSlaMap[id] = {};\n        }\n        const { startTime = undefined, endTime = undefined } = updatedSlaMap[id];\n        // We always recalculate start times and end times, in case the config has been edited.\n        const newStartTime = getStartTime(actions, startCondition);\n        const startTimeHasChanged = newStartTime !== startTime;\n        const newEndTime = startTime || newStartTime ? getEndTime(actions, endCondition, startTime || newStartTime) : undefined;\n        const endTimeHasChanged = newEndTime !== endTime;\n        if (startTimeHasChanged) {\n            hasChanged = true;\n            updatedSlaMap[id].startTime = newStartTime;\n        }\n        if (endTimeHasChanged) {\n            hasChanged = true;\n            updatedSlaMap[id].endTime = newEndTime;\n        }\n    });\n    return hasChanged ? updatedSlaMap : undefined;\n};\n// Find and remove any data from configs that have been since-deleted\nconst getSlaDataWithRemovals = (configs, slaMap) => {\n    const keys = Object.keys(slaMap);\n    if (keys.length === 0) {\n        return undefined;\n    }\n    const configIds = configs.map(config => config.id);\n    let removed = undefined;\n    keys.forEach(key => {\n        if (configIds.indexOf(key) === -1) {\n            removed = true;\n            delete slaMap[key];\n        }\n    });\n    return removed ? slaMap : undefined;\n};\nconst updateConfigs = (t, configs, slaMap, actions) => {\n    const updatedSlaData = getUpdatedSlaData(actions, configs, slaMap);\n    if (updatedSlaData) {\n        const slaDataWithRemovals = getSlaDataWithRemovals(configs, updatedSlaData);\n        const result = slaDataWithRemovals ? slaDataWithRemovals : updatedSlaData;\n        Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"setSlaData\"])(t, result);\n    }\n    else {\n        const slaDataWithRemovals = getSlaDataWithRemovals(configs, slaMap);\n        if (slaDataWithRemovals) {\n            Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"setSlaData\"])(t, slaDataWithRemovals);\n        }\n    }\n};\nconst getActionsPerCard = (actions) => {\n    const map = {};\n    actions.forEach(action => {\n        if (map[action.data.card.id] === undefined) {\n            map[action.data.card.id] = [];\n        }\n        map[action.data.card.id].push(action);\n    });\n    return map;\n};\nconst updateAllConfigs = (t) => __awaiter(void 0, void 0, void 0, function* () {\n    const token = yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getToken\"])(t);\n    if (!token) {\n        return [];\n    }\n    const configs = yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getConfigurations\"])(t);\n    if (!configs) {\n        return [];\n    }\n    const actions = yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getBoardActions\"])(t);\n    const actionsPerCard = getActionsPerCard(actions);\n    const cardIds = Object.keys(actionsPerCard);\n    const slaMap = yield Object(_trello_util__WEBPACK_IMPORTED_MODULE_0__[\"getSlaData\"])(t);\n    cardIds.forEach(cardId => {\n        const cardActions = actionsPerCard[cardId];\n        updateConfigs(t, configs, slaMap || {}, cardActions);\n    });\n});\n// https://gist.github.com/jed/982883\nconst generateUuid = function () { return (\"\" + 1e7 + -1e3 + -4e3 + -8e3 + -1e11).replace(/1|0/g, function () { return (0 | Math.random() * 16).toString(16); }); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdXRpbC50cz80OTU2Il0sInNvdXJjZXNDb250ZW50IjpbImRlY2xhcmUgY29uc3QgbW9tZW50OiBhbnk7XG5cbmltcG9ydCB7IGdldFRva2VuLCBzZXRTbGFEYXRhLCBTbGFEYXRhTWFwLCBTbGFDb25maWd1cmF0aW9uLCBnZXRDYXJkQWN0aW9ucywgZ2V0Qm9hcmRBY3Rpb25zLCBDYXJkQWN0aW9uLCBDYXJkQWN0aW9uVHlwZSwgU2xhQ29uZGl0aW9uLCBnZXRDb25maWd1cmF0aW9ucywgQm9hcmRBY3Rpb24sIGdldFNsYURhdGEgfSBmcm9tICcuL3RyZWxsby11dGlsJztcblxudHlwZSBDYXJkQmFkZ2UgPSB7XG4gIHRleHQ6IHN0cmluZztcbiAgY29sb3I6IHN0cmluZztcbiAgcmVmcmVzaDogbnVtYmVyO1xuICBpY29uPzogc3RyaW5nO1xuICB0aXRsZT86IHN0cmluZztcbn07XG5cbnR5cGUgQ2FyZERldGFpbGVkQmFkZ2UgPSB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbiAgY2FsbGJhY2s/OiAoKSA9PiB7fTtcbn07XG5cbmV4cG9ydCBjb25zdCB0cnVuY2F0ZSA9IChzdHI6IHN0cmluZywgbjogbnVtYmVyLCBzaG91bGRFbGxpcHNlOiBib29sZWFuKTogc3RyaW5nID0+XG4gICAgKHN0ci5sZW5ndGggPiBuKSA/IHN0ci5zdWJzdHIoMCwgbi0xKSArIGAke3Nob3VsZEVsbGlwc2UgPyAnJmhlbGxpcDsnIDogJyd9YCA6IHN0cjtcblxuZXhwb3J0IGNvbnN0IGdldEh1bWFuUmVhZGFibGVUaW1lID0gKHJlYWxNaW51dGVzOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSByZWFsTWludXRlcyA8IDA7XG4gICAgY29uc3QgbWludXRlcyA9IGlzTmVnYXRpdmUgPyByZWFsTWludXRlcyAqIC0xIDogcmVhbE1pbnV0ZXM7XG4gICAgY29uc3QgbmVnYXRpdmVTaWduID0gaXNOZWdhdGl2ZSA/ICctJyA6ICcnO1xuXG4gICAgY29uc3QgTUlOVVRFUyA9ICdtaW4nO1xuICAgIGNvbnN0IEhPVVJTID0gJ2gnO1xuICAgIGNvbnN0IERBWVMgPSAnZCc7XG5cbiAgICBpZiAobWludXRlcyA8IDYwKSB7XG4gICAgICAgIHJldHVybiBgJHtuZWdhdGl2ZVNpZ259JHttaW51dGVzfSR7TUlOVVRFU31gO1xuICAgIH0gaWYgKG1pbnV0ZXMgPCAxNDQwKSB7XG4gICAgICAgIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBjb25zdCBob3Vyc1N0cmluZyA9IGhvdXJzID4gMCA/IGAke2hvdXJzfSR7SE9VUlN9YCA6ICcnO1xuICAgICAgICBjb25zdCByZW1haW5pbmdNaW51dGVzID0gbWludXRlcyAtIDYwICogaG91cnM7XG4gICAgICAgIGNvbnN0IG1pbnV0ZXNTdHJpbmcgPSByZW1haW5pbmdNaW51dGVzID4gMCA/IGAke3JlbWFpbmluZ01pbnV0ZXN9JHtNSU5VVEVTfWAgOiAnJztcbiAgICAgICAgY29uc3Qgc3BhY2VyID0gaG91cnNTdHJpbmcgJiYgbWludXRlc1N0cmluZyA/ICcgJyA6ICcnO1xuICAgICAgICByZXR1cm4gYCR7bmVnYXRpdmVTaWdufSR7aG91cnNTdHJpbmd9JHtzcGFjZXJ9JHttaW51dGVzU3RyaW5nfWA7XG4gICAgfSBcbiAgICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gMTQ0MCk7XG4gICAgY29uc3QgZGF5c1N0cmluZyA9IGRheXMgPiAwID8gYCR7ZGF5c30ke0RBWVN9YCA6ICcnO1xuICAgIGNvbnN0IHJlbWFpbmluZ01pbnV0ZXMgPSBtaW51dGVzIC0gZGF5cyAqIDE0NDA7XG4gICAgY29uc3QgcmVtYWluaW5nSG91cnMgPSBNYXRoLmZsb29yKHJlbWFpbmluZ01pbnV0ZXMgLyA2MCk7IFxuICAgIGNvbnN0IGhvdXJzU3RyaW5nID0gcmVtYWluaW5nSG91cnMgPiAwID8gYCR7cmVtYWluaW5nSG91cnN9JHtIT1VSU31gIDogJyc7XG4gICAgY29uc3Qgc3BhY2VyID0gZGF5c1N0cmluZyAmJiBob3Vyc1N0cmluZyA/ICcgJyA6ICcnO1xuICAgIHJldHVybiBgJHtuZWdhdGl2ZVNpZ259JHtkYXlzU3RyaW5nfSR7c3BhY2VyfSR7aG91cnNTdHJpbmd9YDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRNaW51dGVzUmVtYWluaW5nID0gKHN0YXJ0VGltZTogbnVtYmVyLCBlbmRUaW1lOiBudW1iZXIsIGNvbmZpZzogU2xhQ29uZmlndXJhdGlvbik6IG51bWJlciA9PiB7XG4gICAgY29uc3QgbWludXRlc0VsYXBzZWQgPSBNYXRoLmZsb29yKChlbmRUaW1lIC0gc3RhcnRUaW1lKSAvIDEwMDAgLyA2MCk7XG4gICAgY29uc3QgbWludXRlc1JlbWFpbmluZyA9IGNvbmZpZy50aW1lIC0gbWludXRlc0VsYXBzZWQ7XG4gICAgcmV0dXJuIG1pbnV0ZXNSZW1haW5pbmc7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q29sb3IgPSAobWludXRlc1JlbWFpbmluZzogbnVtYmVyLCBpc0NvbXBsZXRlOiBib29sZWFuKTogc3RyaW5nID0+IHtcbiAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gJ2dyZXknO1xuICAgIH07XG5cbiAgICBpZiAobWludXRlc1JlbWFpbmluZyA8IDApIHtcbiAgICAgICAgcmV0dXJuICdyZWQnO1xuICAgIH0gZWxzZSBpZiAobWludXRlc1JlbWFpbmluZyA8IDYwKSB7XG4gICAgICAgIHJldHVybiAneWVsbG93JztcbiAgICB9XG4gICAgcmV0dXJuICdncmVlbic7XG59O1xuXG50eXBlIER5bmFtaWNCYWRnZSA9IHtcbiAgZHluYW1pYzogKCkgPT4gQ2FyZEJhZGdlO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFJ1bm5pbmdTbGFzID0gKGRhdGE6IFNsYURhdGFNYXAsIGNvbmZpZ3M6IFNsYUNvbmZpZ3VyYXRpb25bXSwgZGV0YWlsZWQ6IGJvb2xlYW4pOiBDYXJkQmFkZ2VbXSB8IENhcmREZXRhaWxlZEJhZGdlW10gfCBEeW5hbWljQmFkZ2VbXSA9PiB7XG4gICAgY29uc3QgcnVubmluZ1NsYXMgPSBbXTtcbiAgICBjb25zdCBjb21wbGV0ZVNsYXMgPSBbXTtcbiAgXG4gICAgY29uZmlncy5mb3JFYWNoKChjb25maWcpID0+IHtcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnLmlkXSkge1xuICAgICAgICAgICAgY29uc3QgeyBzdGFydFRpbWUsIGVuZFRpbWUgfSA9IGRhdGFbY29uZmlnLmlkXTtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUgJiYgIWVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBydW5uaW5nU2xhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1bml4ID0gbW9tZW50KCkudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWludXRlc1JlbWFpbmluZyA9IGdldE1pbnV0ZXNSZW1haW5pbmcoc3RhcnRUaW1lLCB1bml4LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHVtYW5SZWFkYWJsZSA9IGdldEh1bWFuUmVhZGFibGVUaW1lKG1pbnV0ZXNSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBodW1hblJlYWRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRDb2xvcihtaW51dGVzUmVtYWluaW5nLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGRldGFpbGVkID8geyB0aXRsZTogYCR7Y29uZmlnLm5hbWV9IC0gT25nb2luZ2AgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oIWRldGFpbGVkID8ge2ljb246IGAke3dpbmRvdy5sb2NhdGlvbn1pbWcvc3RvcHdhdGNoLnN2Z2B9IDoge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2g6IDYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lICYmIGVuZFRpbWUgJiYgZGV0YWlsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW51dGVzUmVtYWluaW5nID0gZ2V0TWludXRlc1JlbWFpbmluZyhzdGFydFRpbWUsIGVuZFRpbWUsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaHVtYW5SZWFkYWJsZSA9IGdldEh1bWFuUmVhZGFibGVUaW1lKG1pbnV0ZXNSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlU2xhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaHVtYW5SZWFkYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGdldENvbG9yKG1pbnV0ZXNSZW1haW5pbmcsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYCR7Y29uZmlnLm5hbWV9IC0gc3RvcHBlZGAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gV2Ugd2FudCB0aGUgY29tcGxldGUgU0xBcyB0byBjb21lIGFmdGVyIHRoZSBydW5uaW5nIG9uZXNcbiAgICBjb25zdCBhbGxTbGFzID0gcnVubmluZ1NsYXMuY29uY2F0KGNvbXBsZXRlU2xhcyk7XG4gICAgXG4gICAgcmV0dXJuIGFsbFNsYXM7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RW5kVGltZSA9IChhY3Rpb25zOiBDYXJkQWN0aW9uW10sIGVuZENvbmRpdGlvbjogU2xhQ29uZGl0aW9uLCBzdGFydFRpbWU6IG51bWJlcik6IG51bWJlciB8IHZvaWQgPT4ge1xuICAgIGxldCBlbmRUaW1lOiBudW1iZXIgfCB2b2lkID0gdW5kZWZpbmVkO1xuICAgIGFjdGlvbnMuZm9yRWFjaCgoYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gQ2FyZEFjdGlvblR5cGUudXBkYXRlQ2FyZCkge1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5kYXRhLmxpc3RBZnRlci5pZCA9PT0gZW5kQ29uZGl0aW9uLmlkICYmXG4gICAgICAgICghZW5kVGltZSB8fCBtb21lbnQoYWN0aW9uLmRhdGUpLnZhbHVlT2YoKSA8IGVuZFRpbWUpICAmJiBcbiAgICAgICAgbW9tZW50KGFjdGlvbi5kYXRlKS52YWx1ZU9mKCkgPiBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBlbmRUaW1lID0gbW9tZW50KGFjdGlvbi5kYXRlKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlbmRUaW1lO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFN0YXJ0VGltZSA9IChhY3Rpb25zOiBDYXJkQWN0aW9uW10sIHN0YXJ0Q29uZGl0aW9uOiBTbGFDb25kaXRpb24pOiBudW1iZXIgfCB2b2lkID0+IHtcbiAgICBsZXQgc3RhcnRUaW1lOiBudW1iZXIgfCB2b2lkID0gdW5kZWZpbmVkO1xuXG4gICAgYWN0aW9ucy5mb3JFYWNoKChhY3Rpb24pID0+IHtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBDYXJkQWN0aW9uVHlwZS5jcmVhdGVDYXJkICYmIGFjdGlvbi5kYXRhLmxpc3QuaWQgPT09IHN0YXJ0Q29uZGl0aW9uLmlkKSB7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSBtb21lbnQoYWN0aW9uLmRhdGUpLnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gQ2FyZEFjdGlvblR5cGUudXBkYXRlQ2FyZCAmJlxuICAgICAgYWN0aW9uLmRhdGEubGlzdEFmdGVyLmlkID09PSBzdGFydENvbmRpdGlvbi5pZCAmJlxuICAgICAgIXN0YXJ0VGltZSB8fCAobW9tZW50KGFjdGlvbi5kYXRlKS52YWx1ZU9mKCkgPCBzdGFydFRpbWUpKSB7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSBtb21lbnQoYWN0aW9uLmRhdGUpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0YXJ0VGltZTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRVcGRhdGVkU2xhRGF0YSA9IChhY3Rpb25zOiBDYXJkQWN0aW9uW10sIGNvbmZpZ3M6IFNsYUNvbmZpZ3VyYXRpb25bXSwgc2xhTWFwOiBTbGFEYXRhTWFwKTogU2xhRGF0YU1hcCB8IHZvaWQgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRTbGFNYXAgPSBzbGFNYXA7XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcblxuICAgIGNvbmZpZ3MuZm9yRWFjaChjb25maWcgPT4ge1xuICAgICAgICBjb25zdCB7IGlkLCBzdGFydENvbmRpdGlvbiwgZW5kQ29uZGl0aW9uIH0gPSBjb25maWc7XG5cbiAgICAgICAgaWYgKCF1cGRhdGVkU2xhTWFwW2lkXSkge1xuICAgICAgICAgICAgdXBkYXRlZFNsYU1hcFtpZF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhcnRUaW1lID0gdW5kZWZpbmVkLCBlbmRUaW1lID0gdW5kZWZpbmVkIH0gPSB1cGRhdGVkU2xhTWFwW2lkXTtcblxuICAgICAgICAvLyBXZSBhbHdheXMgcmVjYWxjdWxhdGUgc3RhcnQgdGltZXMgYW5kIGVuZCB0aW1lcywgaW4gY2FzZSB0aGUgY29uZmlnIGhhcyBiZWVuIGVkaXRlZC5cbiAgICAgICAgY29uc3QgbmV3U3RhcnRUaW1lID0gZ2V0U3RhcnRUaW1lKGFjdGlvbnMsIHN0YXJ0Q29uZGl0aW9uKTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lSGFzQ2hhbmdlZDogYm9vbGVhbiA9IG5ld1N0YXJ0VGltZSAhPT0gc3RhcnRUaW1lO1xuICAgICAgICBjb25zdCBuZXdFbmRUaW1lID0gc3RhcnRUaW1lIHx8IG5ld1N0YXJ0VGltZSA/IGdldEVuZFRpbWUoYWN0aW9ucywgZW5kQ29uZGl0aW9uLCBzdGFydFRpbWUgfHwgbmV3U3RhcnRUaW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZW5kVGltZUhhc0NoYW5nZWQ6IGJvb2xlYW4gPSBuZXdFbmRUaW1lICE9PSBlbmRUaW1lO1xuICAgIFxuICAgICAgICBpZiAoc3RhcnRUaW1lSGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB1cGRhdGVkU2xhTWFwW2lkXS5zdGFydFRpbWUgPSBuZXdTdGFydFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kVGltZUhhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdXBkYXRlZFNsYU1hcFtpZF0uZW5kVGltZSA9IG5ld0VuZFRpbWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gdXBkYXRlZFNsYU1hcCA6IHVuZGVmaW5lZDtcbn07XG5cbi8vIEZpbmQgYW5kIHJlbW92ZSBhbnkgZGF0YSBmcm9tIGNvbmZpZ3MgdGhhdCBoYXZlIGJlZW4gc2luY2UtZGVsZXRlZFxuY29uc3QgZ2V0U2xhRGF0YVdpdGhSZW1vdmFscyA9IChjb25maWdzOiBTbGFDb25maWd1cmF0aW9uW10sIHNsYU1hcDogU2xhRGF0YU1hcCk6IFNsYURhdGFNYXAgfCB2b2lkID0+IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2xhTWFwKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnSWRzID0gY29uZmlncy5tYXAoY29uZmlnID0+IGNvbmZpZy5pZCk7XG5cbiAgICBsZXQgcmVtb3ZlZCA9IHVuZGVmaW5lZDtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGNvbmZpZ0lkcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBzbGFNYXBba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbW92ZWQgPyBzbGFNYXAgOiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlQ29uZmlncyA9ICh0OiBhbnksIGNvbmZpZ3M6IFNsYUNvbmZpZ3VyYXRpb25bXSwgc2xhTWFwOiBTbGFEYXRhTWFwLCBhY3Rpb25zOiBDYXJkQWN0aW9uW10pOiB2b2lkID0+IHtcbiAgICBjb25zdCB1cGRhdGVkU2xhRGF0YSA9IGdldFVwZGF0ZWRTbGFEYXRhKGFjdGlvbnMsIGNvbmZpZ3MsIHNsYU1hcCk7XG4gICAgaWYgKHVwZGF0ZWRTbGFEYXRhKSB7XG4gICAgICAgIGNvbnN0IHNsYURhdGFXaXRoUmVtb3ZhbHMgPSBnZXRTbGFEYXRhV2l0aFJlbW92YWxzKGNvbmZpZ3MsIHVwZGF0ZWRTbGFEYXRhKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2xhRGF0YVdpdGhSZW1vdmFscyA/IHNsYURhdGFXaXRoUmVtb3ZhbHMgOiB1cGRhdGVkU2xhRGF0YTtcbiAgICAgICAgc2V0U2xhRGF0YSh0LCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNsYURhdGFXaXRoUmVtb3ZhbHMgPSBnZXRTbGFEYXRhV2l0aFJlbW92YWxzKGNvbmZpZ3MsIHNsYU1hcCk7XG4gICAgICAgIGlmIChzbGFEYXRhV2l0aFJlbW92YWxzKSB7XG4gICAgICAgICAgICBzZXRTbGFEYXRhKHQsIHNsYURhdGFXaXRoUmVtb3ZhbHMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEFjdGlvbnNQZXJDYXJkID0gKGFjdGlvbnM6IEJvYXJkQWN0aW9uW10pOiB7W2tleTogc3RyaW5nXTogQ2FyZEFjdGlvbltdfSA9PiB7XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgYWN0aW9ucy5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgIGlmIChtYXBbYWN0aW9uLmRhdGEuY2FyZC5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWFwW2FjdGlvbi5kYXRhLmNhcmQuaWRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWFwW2FjdGlvbi5kYXRhLmNhcmQuaWRdLnB1c2goYWN0aW9uKTtcbiAgICB9KTtcbiAgXG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVBbGxDb25maWdzID0gYXN5bmMgKHQ6IGFueSkgPT4ge1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0VG9rZW4odCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlncyA9IGF3YWl0IGdldENvbmZpZ3VyYXRpb25zKHQpO1xuICAgIGlmICghY29uZmlncykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0IGdldEJvYXJkQWN0aW9ucyh0KTtcbiAgICBjb25zdCBhY3Rpb25zUGVyQ2FyZCA9IGdldEFjdGlvbnNQZXJDYXJkKGFjdGlvbnMpO1xuICAgIGNvbnN0IGNhcmRJZHMgPSBPYmplY3Qua2V5cyhhY3Rpb25zUGVyQ2FyZCk7XG5cbiAgICBjb25zdCBzbGFNYXAgPSBhd2FpdCBnZXRTbGFEYXRhKHQpO1xuXG4gICAgY2FyZElkcy5mb3JFYWNoKGNhcmRJZCA9PiB7XG4gICAgICAgIGNvbnN0IGNhcmRBY3Rpb25zID0gYWN0aW9uc1BlckNhcmRbY2FyZElkXTtcbiAgICAgICAgdXBkYXRlQ29uZmlncyh0LCBjb25maWdzLCBzbGFNYXAgfHwge30sIGNhcmRBY3Rpb25zKTtcbiAgICB9KTtcbn07XG5cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVV1aWQgPSBmdW5jdGlvbiAoKTogc3RyaW5nIHsgcmV0dXJuIChcIlwiICsgMWU3ICsgLTFlMyArIC00ZTMgKyAtOGUzICsgLTFlMTEpLnJlcGxhY2UoLzF8MC9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoMCB8IE1hdGgucmFuZG9tKCkgKiAxNikudG9TdHJpbmcoMTYpOyB9KTsgfTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQWlCQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/util.ts\n");

/***/ })

/******/ });